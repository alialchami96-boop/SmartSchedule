=== file: settings.gradle ===
pluginManagement {
    repositories {
        google()
        mavenCentral()
        gradlePluginPortal()
    }
}
dependencyResolutionManagement {
    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
    repositories {
        google()
        mavenCentral()
    }
}
rootProject.name = "SmartSchedule"
include ':app'

=== file: build.gradle ===
plugins {
    id 'com.android.application'
    id 'org.jetbrains.kotlin.android'
    id 'kotlin-kapt'
    id 'com.google.dagger.hilt.android'
}

android {
    namespace 'com.smartschedule'
    compileSdk 34

    defaultConfig {
        applicationId "com.smartschedule"
        minSdk 24
        targetSdk 34
        versionCode 1
        versionName "1.0.0"
        
        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
        
        vectorDrawables {
            useSupportLibrary true
        }
        
        javaCompileOptions {
            annotationProcessorOptions {
                arguments += [
                    "room.schemaLocation": "$projectDir/schemas".toString(),
                    "room.incremental": "true"
                ]
            }
        }
    }

    buildTypes {
        debug {
            applicationIdSuffix ".debug"
            versionNameSuffix "-DEBUG"
            debuggable true
            minifyEnabled false
        }
        
        release {
            minifyEnabled true
            shrinkResources true
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
    }
    
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_17
        targetCompatibility JavaVersion.VERSION_17
    }
    
    kotlinOptions {
        jvmTarget = '17'
        freeCompilerArgs += [
            '-opt-in=kotlin.RequiresOptIn',
            '-Xcontext-receivers'
        ]
    }
    
    buildFeatures {
        compose true
        buildConfig true
    }
    
    composeOptions {
        kotlinCompilerExtensionVersion '1.5.4'
    }
    
    packagingOptions {
        resources {
            excludes += ['/META-INF/{AL2.0,LGPL2.1}', '/META-INF/gradle/incremental.annotation.processors']
        }
    }
}

dependencies {
    // Core Android
    implementation 'androidx.core:core-ktx:1.12.0'
    implementation 'androidx.lifecycle:lifecycle-runtime-ktx:2.7.0'
    implementation 'androidx.lifecycle:lifecycle-viewmodel-ktx:2.7.0'
    implementation 'androidx.lifecycle:lifecycle-runtime-compose:2.7.0'
    implementation 'androidx.activity:activity-compose:1.8.2'

    // Compose BOM
    implementation platform('androidx.compose:compose-bom:2023.10.01')
    implementation 'androidx.compose.ui:ui'
    implementation 'androidx.compose.ui:ui-graphics'
    implementation 'androidx.compose.ui:ui-tooling-preview'
    implementation 'androidx.compose.material3:material3'
    implementation 'androidx.compose.material:material-icons-extended'
    
    // Navigation
    implementation 'androidx.navigation:navigation-compose:2.7.5'
    implementation 'androidx.lifecycle:lifecycle-viewmodel-compose:2.7.0'

    // Room Database
    def room_version = "2.6.0"
    implementation "androidx.room:room-runtime:$room_version"
    implementation "androidx.room:room-ktx:$room_version"
    kapt "androidx.room:room-compiler:$room_version"

    // Hilt Dependency Injection
    def hilt_version = "2.48"
    implementation "com.google.dagger:hilt-android:$hilt_version"
    kapt "com.google.dagger:hilt-compiler:$hilt_version"
    implementation 'androidx.hilt:hilt-navigation-compose:1.1.0'

    // DataStore (لحفظ الإعدادات)
    implementation "androidx.datastore:datastore-preferences:1.0.0"
    
    // Gson (للتحويلات)
    implementation 'com.google.code.gson:gson:2.10.1'
    
    // Coroutines
    implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-android:1.7.3'
    implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-core:1.7.3'
    
    // Timber (للـ Logging)
    implementation 'com.jakewharton.timber:timber:5.0.1'
    
    // Splash Screen
    implementation 'androidx.core:core-splashscreen:1.0.1'

    // Testing
    testImplementation 'junit:junit:4.13.2'
    testImplementation 'org.jetbrains.kotlinx:kotlinx-coroutines-test:1.7.3'
    testImplementation 'app.cash.turbine:turbine:1.0.0'
    testImplementation "androidx.arch.core:core-testing:2.2.0"
    testImplementation "com.google.truth:truth:1.1.5"
    testImplementation "org.mockito.kotlin:mockito-kotlin:5.1.0"
    
    androidTestImplementation 'androidx.test.ext:junit:1.1.5'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.5.1'
    androidTestImplementation platform('androidx.compose:compose-bom:2023.10.01')
    androidTestImplementation 'androidx.compose.ui:ui-test-junit4'
    androidTestImplementation "androidx.room:room-testing:$room_version"
    
    debugImplementation 'androidx.compose.ui:ui-tooling'
    debugImplementation 'androidx.compose.ui:ui-test-manifest'
}

kapt {
    correctErrorTypes true
}

=== file: app/src/main/AndroidManifest.xml ===
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">
    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" 
        tools:ignore="ScopedStorage" />
    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />

    <application
        android:name=".SmartScheduleApp"
        android:allowBackup="true"
        android:dataExtractionRules="@xml/data_extraction_rules"
        android:fullBackupContent="@xml/backup_rules"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:theme="@style/Theme.SmartSchedule">
        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:theme="@style/Theme.SmartSchedule">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
        
        <provider
            android:name="androidx.core.content.FileProvider"
            android:authorities="com.smartschedule.fileprovider"
            android:exported="false"
            android:grantUriPermissions="true">
            <meta-data
                android:name="android.support.FILE_PROVIDER_PATHS"
                android:resource="@xml/file_paths" />
        </provider>
    </application>
</manifest>

=== file: app/src/main/java/com/smartschedule/SmartScheduleApp.kt ===
package com.smartschedule

import android.app.Application
import dagger.hilt.android.HiltAndroidApp
import timber.log.Timber

@HiltAndroidApp
class SmartScheduleApp : Application() {
    override fun onCreate() {
        super.onCreate()
        if (BuildConfig.DEBUG) {
            Timber.plant(Timber.DebugTree())
        }
    }
}

=== file: app/src/main/java/com/smartschedule/MainActivity.kt ===
package com.smartschedule

import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Surface
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.compose.ui.tooling.preview.Preview
import com.smartschedule.presentation.navigation.AppNavigation
import com.smartschedule.ui.theme.SmartScheduleTheme
import dagger.hilt.android.AndroidEntryPoint

@AndroidEntryPoint
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            SmartScheduleTheme {
                Surface(
                    modifier = Modifier.fillMaxSize(),
                    color = MaterialTheme.colorScheme.background
                ) {
                    AppNavigation()
                }
            }
        }
    }
}

@Preview(showBackground = true)
@Composable
fun DefaultPreview() {
    SmartScheduleTheme {
        AppNavigation()
    }
}
app/src/main/res/values/strings.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="app_name">SmartSchedule</string>
    
    <!-- Main Screen -->
    <string name="main_title">SmartSchedule</string>
    <string name="stats_classes">الفصول الدراسية</string>
    <string name="stats_teachers">المدرسون</string>
    <string name="stats_subjects">المواد الدراسية</string>
    <string name="stats_lessons">الحصص</string>
    
    <!-- Actions -->
    <string name="action_view_timetable">عرض الجدول</string>
    <string name="action_generate">إنشاء جدول</string>
    <string name="action_manage_subjects">إدارة المواد</string>
    <string name="action_manage_teachers">إدارة المدرسين</string>
    <string name="action_manage_classes">إدارة الفصول</string>
    <string name="action_settings">الإعدادات</string>
    
    <!-- Common -->
    <string name="save">حفظ</string>
    <string name="cancel">إلغاء</string>
    <string name="delete">حذف</string>
    <string name="edit">تعديل</string>
    <string name="add">إضافة</string>
    <string name="back">رجوع</string>
    <string name="ok">موافق</string>
    <string name="yes">نعم</string>
    <string name="no">لا</string>
    
    <!-- Errors -->
    <string name="error_generic">حدث خطأ، يرجى المحاولة مرة أخرى</string>
    <string name="error_no_data">لا توجد بيانات متاحة</string>
    <string name="error_empty_field">هذا الحقل مطلوب</string>
    <string name="error_invalid_input">القيمة المدخلة غير صحيحة</string>
    
    <!-- Success Messages -->
    <string name="success_saved">تم الحفظ بنجاح</string>
    <string name="success_deleted">تم الحذف بنجاح</string>
    <string name="success_generated">تم إنشاء الجدول بنجاح</string>
    
    <!-- Content Descriptions -->
    <string name="cd_back">رجوع</string>
    <string name="cd_add">إضافة</string>
    <string name="cd_delete">حذف</string>
    <string name="cd_edit">تعديل</string>
    <string name="cd_settings">الإعدادات</string>
</resources>
```

### app/src/main/res/values/themes.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <style name="Theme.SmartSchedule" parent="android:Theme.Material.Light.NoActionBar">
        <item name="android:statusBarColor">@android:color/transparent</item>
        <item name="android:navigationBarColor">@android:color/transparent</item>
        <item name="android:windowLightStatusBar">true</item>
    </style>
</resources>
```

### app/src/main/res/values/colors.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="primary">#2196F3</color>
    <color name="primary_dark">#1976D2</color>
    <color name="accent">#FF5722</color>
    <color name="error">#F44336</color>
    <color name="success">#4CAF50</color>
    <color name="warning">#FF9800</color>
</resources>
```

=== file: app/src/main/java/com/smartschedule/data/di/AppModule.kt ===
package com.smartschedule.data.di

import android.content.Context
import androidx.room.Room
import com.smartschedule.data.database.AppDatabase
import com.smartschedule.data.repository.TimetableRepositoryImpl
import com.smartschedule.domain.repository.TimetableRepository
import com.smartschedule.utils.algorithms.GeneticAlgorithmEngine
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.android.qualifiers.ApplicationContext
import dagger.hilt.components.SingletonComponent
import javax.inject.Singleton

@Module
@InstallIn(SingletonComponent::class)
object AppModule {

    @Provides
    @Singleton
    fun provideAppDatabase(@ApplicationContext context: Context): AppDatabase {
        return Room.databaseBuilder(
            context,
            AppDatabase::class.java,
            AppDatabase.DATABASE_NAME
        )
            .fallbackToDestructiveMigration()
            .build()
    }

    @Provides
    @Singleton
    fun provideTimetableRepository(db: AppDatabase): TimetableRepository {
        return TimetableRepositoryImpl(db)
    }

    @Provides
    @Singleton
    fun provideGeneticEngine(): GeneticAlgorithmEngine = GeneticAlgorithmEngine()
}

=== file: app/src/main/java/com/smartschedule/data/database/AppDatabase.kt ===
package com.smartschedule.data.database

import androidx.room.Database
import androidx.room.RoomDatabase
import androidx.room.TypeConverters
import com.smartschedule.data.database.dao.*
import com.smartschedule.data.database.entities.*

@Database(
    entities = [
        Subject::class,
        Teacher::class,
        SchoolClass::class,
        Room::class,
        LessonEntity::class,
        TimeSlot::class,
        TeacherSubjectCrossRef::class
    ],
    version = 3,
    exportSchema = false
)
@TypeConverters(Converters::class)
abstract class AppDatabase : RoomDatabase() {
    abstract fun subjectDao(): SubjectDao
    abstract fun teacherDao(): TeacherDao
    abstract fun classDao(): ClassDao
    abstract fun roomDao(): RoomDao
    abstract fun lessonDao(): LessonDao
    abstract fun timeSlotDao(): TimeSlotDao

    companion object {
        const val DATABASE_NAME = "smartschedule_db"
    }
}

=== file: app/src/main/java/com/smartschedule/data/database/Converters.kt ===
package com.smartschedule.data.database

import androidx.room.TypeConverter
import com.google.gson.Gson
import com.google.gson.reflect.TypeToken
import com.smartschedule.data.database.entities.RoomType
import com.smartschedule.data.database.entities.TimeSlot
import com.smartschedule.data.database.entities.WeekType

class Converters {
    private val gson = Gson()

    @TypeConverter
    fun fromStringList(value: List<String>?): String = gson.toJson(value ?: emptyList<String>())
    
    @TypeConverter
    fun toStringList(value: String?): List<String> {
        if (value.isNullOrBlank()) return emptyList()
        return try {
            gson.fromJson(value, object : TypeToken<List<String>>() {}.type)
        } catch (e: Exception) {
            emptyList()
        }
    }

    @TypeConverter
    fun fromTimeSlotList(list: List<TimeSlot>?): String = gson.toJson(list ?: emptyList<TimeSlot>())
    
    @TypeConverter
    fun toTimeSlotList(value: String?): List<TimeSlot> {
        if (value.isNullOrBlank()) return emptyList()
        return try {
            gson.fromJson(value, object : TypeToken<List<TimeSlot>>() {}.type)
        } catch (e: Exception) {
            emptyList()
        }
    }

    @TypeConverter
    fun fromRoomType(roomType: RoomType): String = roomType.name

    @TypeConverter
    fun toRoomType(value: String): RoomType = RoomType.valueOf(value)

    @TypeConverter
    fun fromWeekType(weekType: WeekType): String = weekType.name

    @TypeConverter
    fun toWeekType(value: String): WeekType = WeekType.valueOf(value)
}

=== file: app/src/main/java/com/smartschedule/data/database/entities/Subject.kt ===
package com.smartschedule.data.database.entities

import androidx.room.Entity
import androidx.room.PrimaryKey
import java.util.UUID

@Entity(tableName = "subjects")
data class Subject(
    @PrimaryKey val id: String = UUID.randomUUID().toString(),
    val name: String,
    val shortName: String,
    val color: String = "#2196F3",
    val credits: Int = 1,
    val department: String = "",
    val isActive: Boolean = true,
    val createdAt: Long = System.currentTimeMillis()
)

=== file: app/src/main/java/com/smartschedule/data/database/entities/Teacher.kt ===
package com.smartschedule.data.database.entities

import androidx.room.Entity
import androidx.room.PrimaryKey
import java.util.UUID

@Entity(tableName = "teachers")
data class Teacher(
    @PrimaryKey val id: String = UUID.randomUUID().toString(),
    val firstName: String,
    val lastName: String,
    val email: String = "",
    val phone: String = "",
    val maxHoursPerWeek: Int = 20,
    val availableTimeSlots: List<TimeSlot> = emptyList(),
    val subjects: List<String> = emptyList(),
    val isActive: Boolean = true,
    val createdAt: Long = System.currentTimeMillis()
)

=== file: app/src/main/java/com/smartschedule/data/database/entities/SchoolClass.kt ===
package com.smartschedule.data.database.entities

import androidx.room.Entity
import androidx.room.PrimaryKey
import java.util.UUID

@Entity(tableName = "classes")
data class SchoolClass(
    @PrimaryKey val id: String = UUID.randomUUID().toString(),
    val name: String,
    val grade: Int = 1,
    val section: String = "",
    val studentsCount: Int = 0,
    val academicYear: String = "",
    val isActive: Boolean = true,
    val createdAt: Long = System.currentTimeMillis()
)

=== file: app/src/main/java/com/smartschedule/data/database/entities/Room.kt ===
package com.smartschedule.data.database.entities

import androidx.room.Entity
import androidx.room.PrimaryKey
import java.util.UUID

enum class RoomType { CLASSROOM, LAB, AUDITORIUM, GYM, LIBRARY }

@Entity(tableName = "rooms")
data class Room(
    @PrimaryKey val id: String = UUID.randomUUID().toString(),
    val name: String,
    val capacity: Int = 30,
    val roomType: RoomType = RoomType.CLASSROOM,
    val equipment: List<String> = emptyList(),
    val building: String = "",
    val floor: Int = 0,
    val isAvailable: Boolean = true,
    val createdAt: Long = System.currentTimeMillis()
)

=== file: app/src/main/java/com/smartschedule/data/database/entities/TimeSlot.kt ===
package com.smartschedule.data.database.entities

import androidx.room.Entity
import androidx.room.PrimaryKey
import java.util.UUID

@Entity(tableName = "time_slots")
data class TimeSlot(
    @PrimaryKey val id: String = UUID.randomUUID().toString(),
    val startTime: String,
    val endTime: String,
    val period: Int,
    val isBreak: Boolean = false
)

=== file: app/src/main/java/com/smartschedule/data/database/entities/TeacherSubjectCrossRef.kt ===
package com.smartschedule.data.database.entities

import androidx.room.Entity

@Entity(tableName = "teacher_subject_cross_ref", primaryKeys = ["teacherId", "subjectId"])
data class TeacherSubjectCrossRef(val teacherId: String, val subjectId: String)

=== file: app/src/main/java/com/smartschedule/data/database/entities/SubjectWithTeachers.kt ===
package com.smartschedule.data.database.entities

import androidx.room.Embedded
import androidx.room.Junction
import androidx.room.Relation

data class SubjectWithTeachers(
    @Embedded val subject: Subject,
    @Relation(
        parentColumn = "id",
        entityColumn = "id",
        associateBy = Junction(
            TeacherSubjectCrossRef::class,
            parentColumn = "subjectId",
            entityColumn = "teacherId"
        )
    )
    val teachers: List<Teacher>
)

=== file: app/src/main/java/com/smartschedule/data/database/entities/LessonEntity.kt ===
package com.smartschedule.data.database.entities

import androidx.room.Entity
import androidx.room.ForeignKey
import androidx.room.Index
import androidx.room.PrimaryKey
import java.util.UUID

enum class WeekType { EVERY_WEEK, WEEK_A, WEEK_B }

@Entity(
    tableName = "lessons",
    foreignKeys = [
        ForeignKey(entity = Subject::class, parentColumns = ["id"], childColumns = ["subjectId"], onDelete = ForeignKey.SET_NULL),
        ForeignKey(entity = Teacher::class, parentColumns = ["id"], childColumns = ["teacherId"], onDelete = ForeignKey.SET_NULL),
        ForeignKey(entity = SchoolClass::class, parentColumns = ["id"], childColumns = ["classId"], onDelete = ForeignKey.CASCADE),
        ForeignKey(entity = Room::class, parentColumns = ["id"], childColumns = ["roomId"], onDelete = ForeignKey.SET_NULL)
    ],
    indices = [
        Index("subjectId"), Index("teacherId"), Index("classId"), Index("roomId"),
        Index("dayOfWeek"), Index("period"), Index("isActive")
    ]
)
data class LessonEntity(
    @PrimaryKey val id: String = UUID.randomUUID().toString(),
    val subjectId: String? = null,
    val teacherId: String? = null,
    val classId: String,
    val roomId: String? = null,
    var dayOfWeek: Int = 1,
    var period: Int = 1,
    val duration: Int = 45,
    val weekType: WeekType = WeekType.EVERY_WEEK,
    val startDate: Long? = null,
    val endDate: Long? = null,
    val isActive: Boolean = true
) {
    fun copy(): LessonEntity = LessonEntity(
        id, subjectId, teacherId, classId, roomId, dayOfWeek, period, 
        duration, weekType, startDate, endDate, isActive
    )
}

=== file: app/src/main/java/com/smartschedule/data/database/dao/SubjectDao.kt ===
package com.smartschedule.data.database.dao

import androidx.room.*
import com.smartschedule.data.database.entities.*
import kotlinx.coroutines.flow.Flow

@Dao
interface SubjectDao {
    @Query("SELECT * FROM subjects WHERE isActive = 1 ORDER BY name")
    fun getAllActiveSubjects(): Flow<List<Subject>>

    @Query("SELECT * FROM subjects WHERE isActive = 1")
    suspend fun getAllActiveSubjectsSync(): List<Subject>

    @Transaction
    @Query("SELECT * FROM subjects WHERE isActive = 1 ORDER BY name")
    fun getSubjectsWithTeachers(): Flow<List<SubjectWithTeachers>>

    @Query("SELECT * FROM subjects WHERE id = :subjectId")
    suspend fun getSubjectById(subjectId: String): Subject?

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertSubject(subject: Subject)

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertSubjects(subjects: List<Subject>)

    @Update
    suspend fun updateSubject(subject: Subject)

    @Delete
    suspend fun deleteSubject(subject: Subject)

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertTeacherSubjectCrossRef(crossRef: TeacherSubjectCrossRef)

    @Delete
    suspend fun deleteTeacherSubjectCrossRef(crossRef: TeacherSubjectCrossRef)

    @Query("DELETE FROM teacher_subject_cross_ref WHERE subjectId = :subjectId")
    suspend fun deleteAllTeacherSubjectRefsForSubject(subjectId: String)

    @Query("SELECT COUNT(*) FROM subjects WHERE isActive = 1")
    suspend fun getActiveSubjectsCount(): Int
}

=== file: app/src/main/java/com/smartschedule/data/database/dao/TeacherDao.kt ===
package com.smartschedule.data.database.dao

import androidx.room.*
import com.smartschedule.data.database.entities.Teacher
import kotlinx.coroutines.flow.Flow

@Dao
interface TeacherDao {
    @Query("SELECT * FROM teachers WHERE isActive = 1 ORDER BY firstName, lastName")
    fun getAllActiveTeachers(): Flow<List<Teacher>>

    @Query("SELECT * FROM teachers WHERE isActive = 1")
    suspend fun getAllActiveTeachersSync(): List<Teacher>

    @Query("SELECT * FROM teachers WHERE id = :teacherId")
    suspend fun getTeacherById(teacherId: String): Teacher?

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertTeacher(teacher: Teacher)

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertTeachers(teachers: List<Teacher>)

    @Update
    suspend fun updateTeacher(teacher: Teacher)

    @Delete
    suspend fun deleteTeacher(teacher: Teacher)

    @Query("UPDATE teachers SET isActive = 0 WHERE id = :teacherId")
    suspend fun deactivateTeacher(teacherId: String)

    @Query("SELECT COUNT(*) FROM teachers WHERE isActive = 1")
    suspend fun getActiveTeachersCount(): Int
}

=== file: app/src/main/java/com/smartschedule/data/database/dao/ClassDao.kt ===
package com.smartschedule.data.database.dao

import androidx.room.*
import com.smartschedule.data.database.entities.SchoolClass
import kotlinx.coroutines.flow.Flow

@Dao
interface ClassDao {
    @Query("SELECT * FROM classes WHERE isActive = 1 ORDER BY grade, name")
    fun getAllActiveClasses(): Flow<List<SchoolClass>>

    @Query("SELECT * FROM classes WHERE isActive = 1")
    suspend fun getAllActiveClassesSync(): List<SchoolClass>

    @Query("SELECT * FROM classes WHERE id = :classId")
    suspend fun getClassById(classId: String): SchoolClass?

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertClass(schoolClass: SchoolClass)

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertClasses(classes: List<SchoolClass>)

    @Update
    suspend fun updateClass(schoolClass: SchoolClass)

    @Delete
    suspend fun deleteClass(schoolClass: SchoolClass)

    @Query("UPDATE classes SET isActive = 0 WHERE id = :classId")
    suspend fun deactivateClass(classId: String)

    @Query("SELECT COUNT(*) FROM classes WHERE isActive = 1")
    suspend fun getActiveClassesCount(): Int
}

=== file: app/src/main/java/com/smartschedule/data/database/dao/RoomDao.kt ===
package com.smartschedule.data.database.dao

import androidx.room.*
import com.smartschedule.data.database.entities.Room
import kotlinx.coroutines.flow.Flow

@Dao
interface RoomDao {
    @Query("SELECT * FROM rooms WHERE isAvailable = 1 ORDER BY name")
    fun getAllAvailableRooms(): Flow<List<Room>>

    @Query("SELECT * FROM rooms WHERE isAvailable = 1")
    suspend fun getAllAvailableRoomsSync(): List<Room>

    @Query("SELECT * FROM rooms WHERE id = :roomId")
    suspend fun getRoomById(roomId: String): Room?

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertRoom(room: Room)

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertRooms(rooms: List<Room>)

    @Update
    suspend fun updateRoom(room: Room)

    @Delete
    suspend fun deleteRoom(room: Room)

    @Query("SELECT COUNT(*) FROM rooms WHERE isAvailable = 1")
    suspend fun getAvailableRoomsCount(): Int
}

=== file: app/src/main/java/com/smartschedule/data/database/dao/LessonDao.kt ===
package com.smartschedule.data.database.dao

import androidx.room.*
import com.smartschedule.data.database.entities.LessonEntity
import kotlinx.coroutines.flow.Flow

@Dao
interface LessonDao {
    @Query("SELECT * FROM lessons WHERE isActive = 1 ORDER BY dayOfWeek, period")
    fun getAllLessons(): Flow<List<LessonEntity>>

    @Query("SELECT * FROM lessons WHERE isActive = 1")
    suspend fun getAllLessonsSync(): List<LessonEntity>

    @Query("SELECT * FROM lessons WHERE classId = :classId AND isActive = 1 ORDER BY dayOfWeek, period")
    fun getLessonsForClass(classId: String): Flow<List<LessonEntity>>

    @Query("SELECT * FROM lessons WHERE teacherId = :teacherId AND dayOfWeek = :day AND isActive = 1")
    fun getTeacherLessonsForDay(teacherId: String, day: Int): Flow<List<LessonEntity>>

    @Query("SELECT * FROM lessons WHERE roomId = :roomId AND dayOfWeek = :day AND period = :period AND isActive = 1")
    suspend fun getRoomConflicts(roomId: String, day: Int, period: Int): List<LessonEntity>

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertLesson(lesson: LessonEntity): Long

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertLessons(lessons: List<LessonEntity>)

    @Update
    suspend fun updateLesson(lesson: LessonEntity)

    @Delete
    suspend fun deleteLesson(lesson: LessonEntity)

    @Query("DELETE FROM lessons")
    suspend fun deleteAllLessons()

    @Query("UPDATE lessons SET isActive = 0 WHERE id = :lessonId")
    suspend fun deactivateLesson(lessonId: String)

    @Query("SELECT COUNT(*) FROM lessons WHERE isActive = 1")
    suspend fun getActiveLessonsCount(): Int
}

=== file: app/src/main/java/com/smartschedule/data/database/dao/TimeSlotDao.kt ===
package com.smartschedule.data.database.dao

import androidx.room.*
import com.smartschedule.data.database.entities.TimeSlot
import kotlinx.coroutines.flow.Flow

@Dao
interface TimeSlotDao {
    @Query("SELECT * FROM time_slots ORDER BY period ASC")
    fun getAllTimeSlots(): Flow<List<TimeSlot>>

    @Query("SELECT * FROM time_slots WHERE id = :timeSlotId")
    suspend fun getTimeSlotById(timeSlotId: String): TimeSlot?

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertTimeSlot(timeSlot: TimeSlot)

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertTimeSlots(timeSlots: List<TimeSlot>)

    @Update
    suspend fun updateTimeSlot(timeSlot: TimeSlot)

    @Delete
    suspend fun deleteTimeSlot(timeSlot: TimeSlot)
}

=== file: app/src/main/java/com/smartschedule/domain/models/Lesson.kt ===
package com.smartschedule.domain.models

data class Lesson(
    val id: String,
    val subjectId: String?,
    val teacherId: String?,
    val classId: String,
    val roomId: String?,
    var dayOfWeek: Int,
    var period: Int,
    val duration: Int,
    val weekType: String,
    val startDate: Long?,
    val endDate: Long?
) {
    fun copy(): Lesson = Lesson(
        id, subjectId, teacherId, classId, roomId, dayOfWeek, period, 
        duration, weekType, startDate, endDate
    )
}

=== file: app/src/main/java/com/smartschedule/domain/models/Timetable.kt ===
package com.smartschedule.domain.models

data class Timetable(
    val id: String,
    val lessons: MutableList<Lesson>,
    var fitnessScore: Double = 0.0,
    var conflictCount: Int = 0,
    val createdAt: Long = System.currentTimeMillis()
) {
    fun copy(): Timetable = Timetable(
        id, 
        lessons.map { it.copy() }.toMutableList(), 
        fitnessScore, 
        conflictCount, 
        createdAt
    )
}

=== file: app/src/main/java/com/smartschedule/domain/models/SubjectDomain.kt ===
package com.smartschedule.domain.models

data class SubjectDomain(
    val id: String, 
    val name: String, 
    val shortName: String, 
    val color: String, 
    val credits: Int, 
    val department: String, 
    val isActive: Boolean
)

=== file: app/src/main/java/com/smartschedule/domain/models/Enums.kt ===
package com.smartschedule.domain.models

enum class DayOfWeek(val value: Int) { 
    MON(1), TUE(2), WED(3), THU(4), FRI(5), SAT(6) 
}

=== file: app/src/main/java/com/smartschedule/data/repository/mappers/LessonMapper.kt ===
package com.smartschedule.data.repository.mappers

import com.smartschedule.data.database.entities.LessonEntity
import com.smartschedule.data.database.entities.WeekType
import com.smartschedule.domain.models.Lesson

object LessonMapper {
    fun toDomain(e: LessonEntity): Lesson = Lesson(
        id = e.id,
        subjectId = e.subjectId,
        teacherId = e.teacherId,
        classId = e.classId,
        roomId = e.roomId,
        dayOfWeek = e.dayOfWeek,
        period = e.period,
        duration = e.duration,
        weekType = e.weekType.name,
        startDate = e.startDate,
        endDate = e.endDate
    )

    fun toEntity(d: Lesson): LessonEntity = LessonEntity(
        id = d.id,
        subjectId = d.subjectId,
        teacherId = d.teacherId,
        classId = d.classId,
        roomId = d.roomId,
        dayOfWeek = d.dayOfWeek,
        period = d.period,
        duration = d.duration,
        weekType = WeekType.valueOf(d.weekType),
        startDate = d.startDate,
        endDate = d.endDate
    )
}

=== file: app/src/main/java/com/smartschedule/data/repository/mappers/SubjectMapper.kt ===
package com.smartschedule.data.repository.mappers

import com.smartschedule.data.database.entities.Subject
import com.smartschedule.domain.models.SubjectDomain

object SubjectMapper {
    fun toDomain(e: Subject): SubjectDomain = SubjectDomain(
        e.id, e.name, e.shortName, e.color, e.credits, e.department, e.isActive
    )
    
    fun toEntity(d: SubjectDomain): Subject = Subject(
        id = d.id, name = d.name, shortName = d.shortName, 
        color = d.color, credits = d.credits, department = d.department, 
        isActive = d.isActive
    )
}

=== file: app/src/main/java/com/smartschedule/domain/repository/TimetableRepository.kt ===
package com.smartschedule.domain.repository

import com.smartschedule.data.database.entities.*
import com.smartschedule.domain.models.Timetable
import kotlinx.coroutines.flow.Flow

interface TimetableRepository {
    // Flow operations
    fun getAllSubjects(): Flow<List<Subject>>
    fun getAllTeachers(): Flow<List<Teacher>>
    fun getAllClasses(): Flow<List<SchoolClass>>
    fun getAllRooms(): Flow<List<Room>>
    fun getSubjectsWithTeachers(): Flow<List<SubjectWithTeachers>>
    fun getAllLessons(): Flow<List<LessonEntity>>

    // Sync operations for algorithms
    suspend fun getAllSubjectsSync(): List<Subject>
    suspend fun getAllTeachersSync(): List<Teacher>
    suspend fun getAllClassesSync(): List<SchoolClass>
    suspend fun getAllRoomsSync(): List<Room>

    // CRUD operations
    suspend fun insertSubject(subject: Subject)
    suspend fun insertTeacher(teacher: Teacher)
    suspend fun insertClass(schoolClass: SchoolClass)
    suspend fun insertRoom(room: Room)

    suspend fun updateSubject(subject: Subject)
    suspend fun updateTeacher(teacher: Teacher)
    suspend fun updateClass(schoolClass: SchoolClass)

    suspend fun deleteSubject(subject: Subject)
    suspend fun deleteTeacher(teacher: Teacher)
    suspend fun deleteClass(schoolClass: SchoolClass)

    // Teacher-Subject relationships
    suspend fun assignTeacherToSubject(teacherId: String, subjectId: String)
    suspend fun removeTeacherFromSubject(teacherId: String, subjectId: String)

    // Timetable operations
    suspend fun saveTimetable(timetable: Timetable)
    suspend fun getCurrentTimetable(): Timetable?
    
    // Statistics
    suspend fun getStatistics(): Map<String, Int>
}

=== file: app/src/main/java/com/smartschedule/data/repository/TimetableRepositoryImpl.kt ===
package com.smartschedule.data.repository

import com.smartschedule.data.database.AppDatabase
import com.smartschedule.data.database.entities.*
import com.smartschedule.domain.repository.TimetableRepository
import com.smartschedule.domain.models.Timetable
import com.smartschedule.data.repository.mappers.LessonMapper
import kotlinx.coroutines.flow.Flow
import javax.inject.Inject

class TimetableRepositoryImpl @Inject constructor(
    private val db: AppDatabase
) : TimetableRepository {

    // Flow operations
    override fun getAllSubjects(): Flow<List<Subject>> = db.subjectDao().getAllActiveSubjects()
    override fun getAllTeachers(): Flow<List<Teacher>> = db.teacherDao().getAllActiveTeachers()
    override fun getAllClasses(): Flow<List<SchoolClass>> = db.classDao().getAllActiveClasses()
    override fun getAllRooms(): Flow<List<Room>> = db.roomDao().getAllAvailableRooms()
    override fun getSubjectsWithTeachers(): Flow<List<SubjectWithTeachers>> = 
        db.subjectDao().getSubjectsWithTeachers()
    override fun getAllLessons(): Flow<List<LessonEntity>> = db.lessonDao().getAllLessons()

    // Sync operations
    override suspend fun getAllSubjectsSync(): List<Subject> = 
        db.subjectDao().getAllActiveSubjectsSync()
    override suspend fun getAllTeachersSync(): List<Teacher> = 
        db.teacherDao().getAllActiveTeachersSync()
    override suspend fun getAllClassesSync(): List<SchoolClass> = 
        db.classDao().getAllActiveClassesSync()
    override suspend fun getAllRoomsSync(): List<Room> = 
        db.roomDao().getAllAvailableRoomsSync()

    // CRUD operations
    override suspend fun insertSubject(subject: Subject) = db.subjectDao().insertSubject(subject)
    override suspend fun insertTeacher(teacher: Teacher) = db.teacherDao().insertTeacher(teacher)
    override suspend fun insertClass(schoolClass: SchoolClass) = db.classDao().insertClass(schoolClass)
    override suspend fun insertRoom(room: Room) = db.roomDao().insertRoom(room)

    override suspend fun updateSubject(subject: Subject) = db.subjectDao().updateSubject(subject)
    override suspend fun updateTeacher(teacher: Teacher) = db.teacherDao().updateTeacher(teacher)
    override suspend fun updateClass(schoolClass: SchoolClass) = db.classDao().updateClass(schoolClass)

    override suspend fun deleteSubject(subject: Subject) = db.subjectDao().deleteSubject(subject)
    override suspend fun deleteTeacher(teacher: Teacher) = db.teacherDao().deleteTeacher(teacher)
    override suspend fun deleteClass(schoolClass: SchoolClass) = db.classDao().deleteClass(schoolClass)

    // Teacher-Subject relationships
    override suspend fun assignTeacherToSubject(teacherId: String, subjectId: String) {
        db.subjectDao().insertTeacherSubjectCrossRef(
            TeacherSubjectCrossRef(teacherId = teacherId, subjectId = subjectId)
        )
    }

    override suspend fun removeTeacherFromSubject(teacherId: String, subjectId: String) {
        db.subjectDao().deleteTeacherSubjectCrossRef(
            TeacherSubjectCrossRef(teacherId = teacherId, subjectId = subjectId)
        )
    }

    // Timetable operations
    override suspend fun saveTimetable(timetable: Timetable) {
        db.lessonDao().deleteAllLessons()
        val entities = timetable.lessons.map { LessonMapper.toEntity(it) }
        db.lessonDao().insertLessons(entities)
    }

    override suspend fun getCurrentTimetable(): Timetable? {
        val lessons = db.lessonDao().getAllLessonsSync()
        if (lessons.isEmpty()) return null
        val domainLessons = lessons.map { LessonMapper.toDomain(it) }.toMutableList()
        return Timetable(id = "current", lessons = domainLessons)
    }

    // Statistics
    override suspend fun getStatistics(): Map<String, Int> = mapOf(
        "subjects" to db.subjectDao().getActiveSubjectsCount(),
        "teachers" to db.teacherDao().getActiveTeachersCount(),
        "classes" to db.classDao().getActiveClassesCount(),
        "rooms" to db.roomDao().getAvailableRoomsCount(),
        "lessons" to db.lessonDao().getActiveLessonsCount()
    )
}

=== file: app/src/main/java/com/smartschedule/domain/usecase/GenerateTimetableUseCase.kt ===
package com.smartschedule.domain.usecase

import com.smartschedule.domain.repository.TimetableRepository
import com.smartschedule.utils.algorithms.GeneticAlgorithmEngine
import com.smartschedule.domain.models.Timetable
import javax.inject.Inject

class GenerateTimetableUseCase @Inject constructor(
    private val repository: TimetableRepository,
    private val engine: GeneticAlgorithmEngine
) {
    suspend fun execute(): Result<Timetable> {
        return try {
            val subjects = repository.getAllSubjectsSync()
            val teachers = repository.getAllTeachersSync()
            val classes = repository.getAllClassesSync()
            val rooms = repository.getAllRoomsSync()

            if (subjects.isEmpty() || teachers.isEmpty() || classes.isEmpty()) {
                return Result.failure(Exception("Missing required data: subjects=${subjects.size}, teachers=${teachers.size}, classes=${classes.size}"))
            }

            val result = engine.generate(subjects, teachers, classes, rooms)
            if (result != null) {
                repository.saveTimetable(result)
                Result.success(result)
            } else {
                Result.failure(Exception("Generation failed - no valid timetable found"))
            }
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}

=== file: app/src/main/java/com/smartschedule/domain/usecase/ExportTimetableUseCase.kt ===
package com.smartschedule.domain.usecase

import android.content.Context
import android.graphics.Canvas
import android.graphics.Paint
import android.graphics.pdf.PdfDocument
import android.net.Uri
import androidx.core.content.FileProvider
import com.smartschedule.domain.models.Timetable
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.io.File
import java.io.FileOutputStream
import javax.inject.Inject

class ExportTimetableUseCase @Inject constructor() {

    suspend fun exportToPdf(context: Context, timetable: Timetable, className: String): File? = 
        withContext(Dispatchers.IO) {
        try {
            val pageWidth = 595
            val pageHeight = 842
            val pdf = PdfDocument()
            val pageInfo = PdfDocument.PageInfo.Builder(pageWidth, pageHeight, 1).create()
            val page = pdf.startPage(pageInfo)
            val canvas: Canvas = page.canvas
            val paint = Paint().apply { 
                textSize = 12f
                isAntiAlias = true 
            }

            // Header
            paint.textSize = 18f
            paint.isFakeBoldText = true
            canvas.drawText("Class Schedule - $className", 40f, 40f, paint)
            paint.textSize = 10f
            paint.isFakeBoldText = false

            // Simple tabular layout
            val startX = 40f
            var startY = 80f
            val cellHeight = 18f

            val days = listOf("Mon", "Tue", "Wed", "Thu", "Fri", "Sat")
            canvas.drawText("Period", startX, startY, paint)
            days.forEachIndexed { idx, d -> 
                canvas.drawText(d, startX + (idx + 1) * 70f, startY, paint) 
            }
            startY += cellHeight

            val periods = (1..8)
            periods.forEach { p ->
                canvas.drawText("$p", startX, startY, paint)
                days.forEachIndexed { dayIdx, _ ->
                    val lesson = timetable.lessons.find { 
                        it.dayOfWeek == dayIdx + 1 && it.period == p 
                    }
                    if (lesson != null) {
                        val text = "${lesson.subjectId?.take(6) ?: ""} ${lesson.teacherId?.take(6) ?: ""}"
                        canvas.drawText(text, startX + (dayIdx + 1) * 70f, startY, paint)
                    }
                }
                startY += cellHeight
                if (startY > pageHeight - 60) { /* no pagination implemented here for brevity */ }
            }

            pdf.finishPage(page)
            val outDir = File(context.getExternalFilesDir(null), "exports")
            if (!outDir.exists()) outDir.mkdirs()
            val file = File(outDir, "timetable_${className}_${System.currentTimeMillis()}.pdf")
            FileOutputStream(file).use { pdf.writeTo(it) }
            pdf.close()
            return@withContext file
        } catch (e: Exception) {
            e.printStackTrace()
            return@withContext null
        }
    }

    suspend fun getShareableUri(context: Context, file: File): Uri? = withContext(Dispatchers.IO) {
        try {
            FileProvider.getUriForFile(
                context,
                "com.smartschedule.fileprovider",
                file
            )
        } catch (e: Exception) {
            null
        }
    }
}

=== file: app/src/main/java/com/smartschedule/utils/algorithms/GeneticAlgorithmEngine.kt ===

package com.smartschedule.utils.algorithms

import com.smartschedule.data.database.entities.*
import com.smartschedule.data.local.PreferencesManager
import com.smartschedule.data.repository.mappers.LessonMapper
import com.smartschedule.domain.models.FitnessWeights
import com.smartschedule.domain.models.Timetable as DomainTimetable
import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.sync.Mutex
import kotlinx.coroutines.sync.withLock
import timber.log.Timber
import java.util.*
import kotlin.math.max
import kotlin.random.Random

/**
 * محرك الخوارزمية الجينية المتقدم لإنشاء الجداول الدراسية
 * 
 * يستخدم تقنيات متقدمة:
 * - Tournament Selection للاختيار
 * - Uniform Crossover للتهجين
 * - Adaptive Mutation Rate للتحور التكيفي
 * - Elitism للحفاظ على أفضل الحلول
 * - Fitness Caching لتحسين الأداء
 * 
 * @property preferencesManager لجلب أوزان اللياقة المخصصة
 */
class GeneticAlgorithmEngine @Inject constructor(
    private val preferencesManager: PreferencesManager
) {
    // معاملات الخوارزمية الجينية
    private companion object {
        const val POPULATION_SIZE = 80
        const val MAX_GENERATIONS = 500
        const val INITIAL_MUTATION_RATE = 0.02
        const val CROSSOVER_RATE = 0.85
        const val TOURNAMENT_SIZE = 5
        const val ELITISM_RATE = 0.08
        const val PERIODS_PER_DAY = 8
        const val DAYS_PER_WEEK = 6
        const val STAGNATION_THRESHOLD = 30
        const val HIGH_STAGNATION_THRESHOLD = 50
        const val TARGET_FITNESS = 0.985
        const val CACHE_CLEAR_INTERVAL = 50
    }

    // حالة الخوارزمية
    private var mutationRate = INITIAL_MUTATION_RATE
    private val cancelMutex = Mutex()
    private var cancelled = false
    private val fitnessCache = mutableMapOf<String, Double>()

    // تدفق التقدم
    private val _progress = MutableStateFlow(GenerationProgress())
    val progress: StateFlow<GenerationProgress> = _progress.asStateFlow()

    /**
     * إلغاء عملية التوليد
     */
    suspend fun cancel() = cancelMutex.withLock { 
        cancelled = true 
        Timber.d("Generation cancelled by user")
    }

    /**
     * التحقق من حالة الإلغاء
     */
    private suspend fun isCancelled(): Boolean = cancelMutex.withLock { cancelled }

    /**
     * إعادة تعيين الحالة
     */
    private fun reset() {
        cancelled = false
        fitnessCache.clear()
        mutationRate = INITIAL_MUTATION_RATE
        Timber.d("Engine reset completed")
    }

    /**
     * جلب أوزان اللياقة الحالية
     */
    private suspend fun getCurrentWeights(): FitnessWeights {
        return preferencesManager.fitnessWeights.first()
    }

    /**
     * الدالة الرئيسية لتوليد الجدول الدراسي
     * 
     * @param subjects قائمة المواد الدراسية
     * @param teachers قائمة المدرسين
     * @param classes قائمة الفصول
     * @param rooms قائمة القاعات
     * @return جدول دراسي محسّن أو null في حالة الفشل
     */
    suspend fun generate(
        subjects: List<Subject>,
        teachers: List<Teacher>,
        classes: List<SchoolClass>,
        rooms: List<Room>
    ): DomainTimetable? = withContext(Dispatchers.Default) {
        Timber.d("Starting generation with: ${subjects.size} subjects, ${teachers.size} teachers, ${classes.size} classes, ${rooms.size} rooms")
        
        reset()
        updateProgress(currentStep = "جاري تحضير البيانات...")

        // التحقق من البيانات الأساسية
        if (!validateInputData(subjects, teachers, classes, rooms)) {
            updateProgress(isCompleted = true, currentStep = "بيانات غير كافية")
            return@withContext null
        }

        var population = createInitialPopulation(subjects, teachers, classes, rooms)
        var bestTimetable: DomainTimetable? = null
        var bestFitnessEver = Double.MIN_VALUE
        var stagnationCounter = 0

        // حلقة التطور الرئيسية
        for (generation in 1..MAX_GENERATIONS) {
            if (isCancelled()) {
                updateProgress(isCompleted = true, currentStep = "تم الإلغاء")
                return@withContext bestTimetable
            }

            updateProgress(
                currentGeneration = generation,
                maxGenerations = MAX_GENERATIONS,
                currentStep = "جيل $generation: تقييم اللياقة..."
            )

            // تقييم اللياقة بالتوازي
            val evaluated = evaluatePopulationParallel(
                population, subjects, teachers, classes, rooms
            )

            // تحديث أفضل حل
            val currentBest = evaluated.maxByOrNull { it.fitnessScore }
            if (currentBest != null && currentBest.fitnessScore > bestFitnessEver + 1e-9) {
                bestTimetable = currentBest.copy()
                bestFitnessEver = currentBest.fitnessScore
                stagnationCounter = 0
                Timber.d("New best fitness: $bestFitnessEver at generation $generation")
            } else {
                stagnationCounter++
            }

            updateProgress(
                currentGeneration = generation,
                bestFitness = bestFitnessEver,
                currentStep = "أفضل لياقة: ${String.format("%.2f%%", bestFitnessEver * 100)}"
            )

            // إنهاء مبكر للحلول عالية الجودة
            if (bestFitnessEver >= TARGET_FITNESS) {
                updateProgress(isCompleted = true, currentStep = "تم العثور على حل ممتاز!")
                Timber.i("High quality solution found: $bestFitnessEver")
                return@withContext bestTimetable
            }

            // التكيف مع الركود
            adaptMutationRate(stagnationCounter)

            // إنشاء الجيل التالي
            population = createNextGeneration(evaluated, subjects, teachers, classes, rooms)

            // تنظيف ذاكرة التخزين المؤقت دورياً
            if (generation % CACHE_CLEAR_INTERVAL == 0) {
                fitnessCache.clear()
                Timber.d("Cache cleared at generation $generation")
            }
        }

        updateProgress(isCompleted = true, currentStep = "اكتمل التوليد")
        Timber.i("Generation completed. Best fitness: $bestFitnessEver")
        
        return@withContext bestTimetable ?: population.maxByOrNull { it.fitnessScore }?.copy()
    }

    /**
     * التحقق من صحة البيانات المدخلة
     */
    private fun validateInputData(
        subjects: List<Subject>,
        teachers: List<Teacher>,
        classes: List<SchoolClass>,
        rooms: List<Room>
    ): Boolean {
        return subjects.isNotEmpty() && 
               teachers.isNotEmpty() && 
               classes.isNotEmpty() && 
               rooms.isNotEmpty()
    }

    /**
     * تحديث حالة التقدم
     */
    private fun updateProgress(
        currentGeneration: Int = _progress.value.currentGeneration,
        maxGenerations: Int = _progress.value.maxGenerations,
        bestFitness: Double = _progress.value.bestFitness,
        currentStep: String = _progress.value.currentStep,
        isCompleted: Boolean = _progress.value.isCompleted
    ) {
        _progress.value = GenerationProgress(
            currentGeneration = currentGeneration,
            maxGenerations = maxGenerations,
            bestFitness = bestFitness,
            currentStep = currentStep,
            isCompleted = isCompleted
        )
    }

    /**
     * تكييف معدل التحور بناءً على الركود
     */
    private fun adaptMutationRate(stagnationCounter: Int) {
        mutationRate = when {
            stagnationCounter > HIGH_STAGNATION_THRESHOLD -> 
                (mutationRate + 0.02).coerceAtMost(0.25)
            stagnationCounter > STAGNATION_THRESHOLD -> 
                (mutationRate + 0.01).coerceAtMost(0.15)
            else -> INITIAL_MUTATION_RATE
        }
    }

    /**
     * إنشاء مجموعة أولية من الجداول
     */
    private fun createInitialPopulation(
        subjects: List<Subject>,
        teachers: List<Teacher>,
        classes: List<SchoolClass>,
        rooms: List<Room>
    ): MutableList<DomainTimetable> {
        Timber.d("Creating initial population of size $POPULATION_SIZE")
        return MutableList(POPULATION_SIZE) {
            createRandomTimetable(subjects, teachers, classes, rooms)
        }
    }

    /**
     * إنشاء جدول عشوائي مع تجنب التعارضات الأساسية
     */
    private fun createRandomTimetable(
        subjects: List<Subject>,
        teachers: List<Teacher>,
        classes: List<SchoolClass>,
        rooms: List<Room>
    ): DomainTimetable {
        val lessons = mutableListOf<LessonEntity>()
        val rand = Random(System.nanoTime())
        
        // تخطيط المدرسين حسب المواد
        val teachersBySubject = subjects.associate { subject ->
            subject.id to teachers.filter { it.subjects.contains(subject.id) }.map { it.id }
        }

        // تتبع الحجوزات
        val teacherBookings = mutableMapOf<String, MutableSet<Pair<Int, Int>>>()
        val roomBookings = mutableMapOf<String, MutableSet<Pair<Int, Int>>>()
        val classBookings = mutableMapOf<String, MutableSet<Pair<Int, Int>>>()

        // إنشاء حصص لكل فصل
        for (schoolClass in classes) {
            for (day in 1..DAYS_PER_WEEK) {
                for (period in 1..PERIODS_PER_DAY) {
                    val subject = subjects.random(rand)
                    
                    // اختيار مدرس مناسب
                    val availableTeachers = teachersBySubject[subject.id]?.filter {
                        !isBooked(teacherBookings, it, day, period)
                    } ?: emptyList()
                    
                    val teacherId = availableTeachers.randomOrNull(rand) 
                        ?: teachers.random(rand).id

                    // اختيار قاعة مناسبة
                    val suitableRooms = rooms.filter { room ->
                        room.capacity >= schoolClass.studentsCount &&
                        !isBooked(roomBookings, room.id, day, period)
                    }
                    
                    val roomId = suitableRooms.randomOrNull(rand)?.id 
                        ?: rooms.random(rand).id

                    // تسجيل الحجوزات
                    bookSlot(teacherBookings, teacherId, day, period)
                    bookSlot(roomBookings, roomId, day, period)
                    bookSlot(classBookings, schoolClass.id, day, period)

                    lessons.add(
                        LessonEntity(
                            id = "L_${UUID.randomUUID()}",
                            subjectId = subject.id,
                            teacherId = teacherId,
                            classId = schoolClass.id,
                            roomId = roomId,
                            dayOfWeek = day,
                            period = period
                        )
                    )
                }
            }
        }

        val domainLessons = lessons.map { LessonMapper.toDomain(it) }.toMutableList()
        return DomainTimetable(
            id = "T_${UUID.randomUUID()}",
            lessons = domainLessons
        )
    }

    /**
     * التحقق من حجز موعد
     */
    private fun isBooked(
        bookings: Map<String, Set<Pair<Int, Int>>>,
        id: String,
        day: Int,
        period: Int
    ): Boolean {
        return bookings[id]?.contains(day to period) ?: false
    }

    /**
     * حجز موعد
     */
    private fun bookSlot(
        bookings: MutableMap<String, MutableSet<Pair<Int, Int>>>,
        id: String,
        day: Int,
        period: Int
    ) {
        bookings.getOrPut(id) { mutableSetOf() }.add(day to period)
    }

    /**
     * تقييم اللياقة بشكل متوازي
     */
    private suspend fun evaluatePopulationParallel(
        population: List<DomainTimetable>,
        subjects: List<Subject>,
        teachers: List<Teacher>,
        classes: List<SchoolClass>,
        rooms: List<Room>
    ): List<DomainTimetable> = coroutineScope {
        population.map { timetable ->
            async {
                timetable.apply {
                    fitnessScore = calculateFitnessWithCaching(
                        this, subjects, teachers, classes, rooms
                    )
                }
            }
        }.awaitAll()
    }

    /**
     * حساب اللياقة مع التخزين المؤقت
     */
    private suspend fun calculateFitnessWithCaching(
        timetable: DomainTimetable,
        subjects: List<Subject>,
        teachers: List<Teacher>,
        classes: List<SchoolClass>,
        rooms: List<Room>
    ): Double {
        val cacheKey = generateCacheKey(timetable)
        
        return fitnessCache.getOrPut(cacheKey) {
            calculateFitness(timetable, subjects, teachers, classes, rooms)
        }
    }

    /**
     * توليد مفتاح التخزين المؤقت
     */
    private fun generateCacheKey(timetable: DomainTimetable): String {
        return timetable.lessons.joinToString("|") {
            "${it.dayOfWeek}:${it.period}:${it.teacherId}:${it.roomId}:${it.classId}"
        }
    }

    /**
     * حساب اللياقة الكلية للجدول
     * 
     * يأخذ في الاعتبار:
     * - القيود الصلبة (تعارضات المدرسين، الفصول، القاعات)
     * - القيود الناعمة (توزيع الحصص، الفجوات، العبء)
     * 
     * @return قيمة بين 0 و 1 (1 = الأفضل)
     */
    private suspend fun calculateFitness(
        timetable: DomainTimetable,
        subjects: List<Subject>,
        teachers: List<Teacher>,
        classes: List<SchoolClass>,
        rooms: List<Room>
    ): Double {
        if (timetable.lessons.isEmpty()) return 0.0

        val weights = getCurrentWeights()
        val lessons = timetable.lessons

        // خرائط للبحث السريع
        val teacherMap = teachers.associateBy { it.id }
        val roomMap = rooms.associateBy { it.id }
        val classMap = classes.associateBy { it.id }
        val subjectMap = subjects.associateBy { it.id }

        // حساب المقاييس
        val metrics = FitnessMetrics(
            teacherConflicts = calculateTeacherConflicts(lessons),
            classConflicts = calculateClassConflicts(lessons),
            roomConflicts = calculateRoomConflicts(lessons),
            teacherSubjectMismatch = calculateTeacherSubjectMismatch(
                lessons, teacherMap, subjectMap
            ),
            roomCapacityViolations = calculateRoomCapacityViolations(
                lessons, roomMap, classMap
            ),
            distributionPenalty = calculateDistributionPenalty(lessons),
            gapPenalty = calculateGapPenalty(lessons),
            teacherLoadPenalty = calculateTeacherLoadPenalty(lessons, teacherMap),
            roomUtilizationPenalty = calculateRoomUtilizationPenalty(lessons, roomMap)
        )

        // حساب العقوبات
        val hardPenalty = calculateHardPenalty(metrics, weights)
        val softPenalty = calculateSoftPenalty(metrics, weights)

        // الدرجة النهائية
        var score = 1.0 - (hardPenalty + softPenalty)
        score = score.coerceIn(0.0, 1.0)

        // تحديث معلومات الجدول
        timetable.conflictCount = (
            metrics.teacherConflicts + 
            metrics.classConflicts + 
            metrics.roomConflicts
        ).toInt()
        timetable.fitnessScore = score

        return score
    }

    /**
     * فئة لتخزين مقاييس اللياقة
     */
    private data class FitnessMetrics(
        val teacherConflicts: Double,
        val classConflicts: Double,
        val roomConflicts: Double,
        val teacherSubjectMismatch: Double,
        val roomCapacityViolations: Double,
        val distributionPenalty: Double,
        val gapPenalty: Double,
        val teacherLoadPenalty: Double,
        val roomUtilizationPenalty: Double
    )

    /**
     * حساب العقوبات الصلبة
     */
    private fun calculateHardPenalty(
        metrics: FitnessMetrics,
        weights: FitnessWeights
    ): Double {
        return (metrics.teacherConflicts * weights.teacherConflict) +
               (metrics.classConflicts * weights.classConflict) +
               (metrics.roomConflicts * weights.roomConflict) +
               (metrics.teacherSubjectMismatch * weights.teacherSubjectMismatch) +
               (metrics.roomCapacityViolations * weights.roomCapacityViolation)
    }

    /**
     * حساب العقوبات الناعمة
     */
    private fun calculateSoftPenalty(
        metrics: FitnessMetrics,
        weights: FitnessWeights
    ): Double {
        return (metrics.distributionPenalty * weights.distributionPenalty) +
               (metrics.gapPenalty * weights.gapPenalty) +
               (metrics.teacherLoadPenalty * weights.teacherLoadPenalty) +
               (metrics.roomUtilizationPenalty * weights.roomUtilizationPenalty)
    }

    // دوال حساب المقاييس الفردية
    
    private fun calculateTeacherConflicts(
        lessons: List<com.smartschedule.domain.models.Lesson>
    ): Double {
        return lessons
            .groupBy { "${it.teacherId}_${it.dayOfWeek}_${it.period}" }
            .values
            .sumOf { group -> max(0, group.size - 1).toDouble() }
    }

    private fun calculateClassConflicts(
        lessons: List<com.smartschedule.domain.models.Lesson>
    ): Double {
        return lessons
            .groupBy { "${it.classId}_${it.dayOfWeek}_${it.period}" }
            .values
            .sumOf { group -> max(0, group.size - 1).toDouble() }
    }

    private fun calculateRoomConflicts(
        lessons: List<com.smartschedule.domain.models.Lesson>
    ): Double {
        return lessons
            .groupBy { "${it.roomId}_${it.dayOfWeek}_${it.period}" }
            .values
            .sumOf { group -> max(0, group.size - 1).toDouble() }
    }

    private fun calculateTeacherSubjectMismatch(
        lessons: List<com.smartschedule.domain.models.Lesson>,
        teacherMap: Map<String, Teacher>,
        subjectMap: Map<String, Subject>
    ): Double {
        var mismatches = 0.0
        lessons.forEach { lesson ->
            val teacher = lesson.teacherId?.let { teacherMap[it] }
            val subjectId = lesson.subjectId
            
            if (teacher != null && subjectId != null) {
                if (!teacher.subjects.contains(subjectId)) {
                    mismatches += 1.0
                }
            }
        }
        return mismatches
    }

    private fun calculateRoomCapacityViolations(
        lessons: List<com.smartschedule.domain.models.Lesson>,
        roomMap: Map<String, Room>,
        classMap: Map<String, SchoolClass>
    ): Double {
        var violations = 0.0
        lessons.forEach { lesson ->
            val room = lesson.roomId?.let { roomMap[it] }
            val schoolClass = lesson.classId.let { classMap[it] }
            
            if (room != null && schoolClass != null) {
                if (room.capacity < schoolClass.studentsCount) {
                    violations += 1.0
                }
            }
        }
        return violations
    }

    private fun calculateDistributionPenalty(
        lessons: List<com.smartschedule.domain.models.Lesson>
    ): Double {
        val classSubjectDistribution = lessons
            .groupBy { "${it.classId}_${it.subjectId}" }
            .mapValues { (_, subjectLessons) ->
                val daysUsed = subjectLessons.map { it.dayOfWeek }.distinct().size
                val totalLessons = subjectLessons.size
                
                if (totalLessons <= 1) {
                    0.0
                } else {
                    val idealDistribution = minOf(totalLessons, DAYS_PER_WEEK)
                    (idealDistribution - daysUsed).toDouble() / idealDistribution
                }
            }
        
        return if (classSubjectDistribution.isEmpty()) {
            0.0
        } else {
            classSubjectDistribution.values.average()
        }
    }

    private fun calculateGapPenalty(
        lessons: List<com.smartschedule.domain.models.Lesson>
    ): Double {
        var totalGaps = 0
        val grouped = lessons.groupBy { "${it.classId}_${it.dayOfWeek}" }
        
        grouped.forEach { (_, dayLessons) ->
            val periods = dayLessons.map { it.period }.sorted()
            for (i in 0 until periods.size - 1) {
                val gap = periods[i + 1] - periods[i] - 1
                if (gap > 0) totalGaps += gap
            }
        }
        
        return if (lessons.isEmpty()) 0.0 else totalGaps.toDouble() / lessons.size
    }

    private fun calculateTeacherLoadPenalty(
        lessons: List<com.smartschedule.domain.models.Lesson>,
        teacherMap: Map<String, Teacher>
    ): Double {
        var penalty = 0.0
        val teacherLoad = lessons.groupingBy { it.teacherId }.eachCount()
        
        teacherLoad.forEach { (teacherId, load) ->
            val teacher = teacherId?.let { teacherMap[it] }
            if (teacher != null) {
                val maxLoad = teacher.maxHoursPerWeek
                if (load > maxLoad) {
                    penalty += (load - maxLoad).toDouble() / maxLoad
                }
            }
        }
        
        return penalty / teacherMap.size.coerceAtLeast(1)
    }

    private fun calculateRoomUtilizationPenalty(
        lessons: List<com.smartschedule.domain.models.Lesson>,
        roomMap: Map<String, Room>
    ): Double {
        val roomUsage = lessons.groupingBy { it.roomId }.eachCount()
        val totalPossibleSlots = DAYS_PER_WEEK * PERIODS_PER_DAY
        var penalty = 0.0
        
        roomMap.keys.forEach { roomId ->
            val usage = roomUsage[roomId] ?: 0
            val utilization = usage.toDouble() / totalPossibleSlots
            
            if (utilization < 0.2) {
                penalty += (0.2 - utilization)
            }
        }
        
        return penalty / roomMap.size.coerceAtLeast(1)
    }

    /**
     * إنشاء الجيل التالي من خلال الاختيار والتهجين والتحور
     */
    private fun createNextGeneration(
        population: List<DomainTimetable>,
        subjects: List<Subject>,
        teachers: List<Teacher>,
        classes: List<SchoolClass>,
        rooms: List<Room>
    ): MutableList<DomainTimetable> {
        val nextGen = mutableListOf<DomainTimetable>()
        val eliteCount = max(1, (POPULATION_SIZE * ELITISM_RATE).toInt())
        
        // النخبوية: الحفاظ على أفضل الأفراد
        val sorted = population.sortedByDescending { it.fitnessScore }
        nextGen.addAll(sorted.take(eliteCount).map { it.copy() })

        // إنشاء باقي المجموعة
        while (nextGen.size < POPULATION_SIZE) {
            if (Random.nextDouble() < CROSSOVER_RATE) {
                val parent1 = tournamentSelection(population)
                val parent2 = tournamentSelection(population)
                val child = crossover(parent1, parent2)
                mutate(child, subjects, teachers, classes, rooms)
                nextGen.add(child)
            } else {
                val individual = tournamentSelection(population).copy()
                mutate(individual, subjects, teachers, classes, rooms)
                nextGen.add(individual)
            }
        }
        
        return nextGen
    }

    /**
     * اختيار البطولة: اختيار أفضل فرد من عينة عشوائية
     */
    private fun tournamentSelection(population: List<DomainTimetable>): DomainTimetable {
        return population
            .shuffled()
            .take(TOURNAMENT_SIZE)
            .maxByOrNull { it.fitnessScore }!!
            .copy()
    }

    /**
     * التهجين الموحد: دمج جينات الوالدين بشكل عشوائي
     */
    private fun crossover(
        parent1: DomainTimetable,
        parent2: DomainTimetable
    ): DomainTimetable {
        val childLessons = mutableListOf<LessonEntity>()
        val rand = Random(System.nanoTime())
        
        val minSize = minOf(parent1.lessons.size, parent2.lessons.size)
        
        for (i in 0 until minSize) {
            val source = if (rand.nextDouble() < 0.5) {
                parent2.lessons[i]
            } else {
                parent1.lessons[i]
            }
            
            childLessons.add(
                LessonMapper.toEntity(source.copy(id = "L_${UUID.randomUUID()}"))
            )
        }

        val domainChildLessons = childLessons.map { 
            LessonMapper.toDomain(it) 
        }.toMutableList()
        
        return DomainTimetable(
            id = "T_${UUID.randomUUID()}",
            lessons = domainChildLessons
        )
    }

    /**
     * التحور: تطبيق تغييرات عشوائية على الجدول
     * 
     * أنواع التحور:
     * 1. تبديل المواعيد
     * 2. تغيير المدرس
     * 3. تغيير القاعة
     * 4. التحرك في الوقت
     */
    private fun mutate(
        timetable: DomainTimetable,
        subjects: List<Subject>,
        teachers: List<Teacher>,
        classes: List<SchoolClass>,
        rooms: List<Room>
    ) {
        if (timetable.lessons.isEmpty()) return
        
        val rand = Random(System.nanoTime())
        val teachersBySubject = subjects.associate { s ->
            s.id to teachers.filter { it.subjects.contains(s.id) }.map { it.id }
        }
        
        val mutations = (timetable.lessons.size * mutationRate)
            .toInt()
            .coerceAtLeast(1)
        
        repeat(mutations) {
            if (rand.nextDouble() < mutationRate) {
                val lessonIndex = rand.nextInt(timetable.lessons.size)
                val lesson = timetable.lessons[lessonIndex]
                
                when (rand.nextInt(4)) {
                    0 -> mutateSwapTimeslot(timetable, lessonIndex, rand)
                    1 -> mutateChangeTeacher(lesson, teachersBySubject, rand)
                    2 -> mutateChangeRoom(lesson, classes, rooms, rand)
                    3 -> mutateTimeShift(lesson, rand)
                }
            }
        }
    }

    /**
     * تبديل المواعيد بين حصتين من نفس الفصل
     */
    private fun mutateSwapTimeslot(
        timetable: DomainTimetable,
        lessonIndex: Int,
        rand: Random
    ) {
        val lesson = timetable.lessons[lessonIndex]
        val otherIndex = rand.nextInt(timetable.lessons.size)
        val other = timetable.lessons[otherIndex]
        
        if (lesson.classId == other.classId) {
            val tempDay = lesson.dayOfWeek
            val tempPeriod = lesson.period
            lesson.dayOfWeek = other.dayOfWeek
            lesson.period = other.period
            other.dayOfWeek = tempDay
            other.period = tempPeriod
        }
    }

    /**
     * تغيير المدرس لمدرس آخر مؤهل
     */
    private fun mutateChangeTeacher(
        lesson: com.smartschedule.domain.models.Lesson,
        teachersBySubject: Map<String, List<String>>,
        rand: Random
    ) {
        val possibleTeachers = teachersBySubject[lesson.subjectId].orEmpty()
        if (possibleTeachers.isNotEmpty()) {
            lesson.teacherId = possibleTeachers[rand.nextInt(possibleTeachers.size)]
        }
    }

    /**
     * تغيير القاعة لقاعة مناسبة أخرى
     */
    private fun mutateChangeRoom(
        lesson: com.smartschedule.domain.models.Lesson,
        classes: List<SchoolClass>,
        rooms: List<Room>,
        rand: Random
    ) {
        val classSize = classes.find { it.id == lesson.classId }?.studentsCount ?: 0
        val suitableRooms = rooms.filter { it.capacity >= classSize }
        
        if (suitableRooms.isNotEmpty()) {
            lesson.roomId = suitableRooms[rand.nextInt(suitableRooms.size)].id
        }
    }

    /**
     * تحريك الحصة في الوقت بشكل طفيف
     */
    private fun mutateTimeShift(
        lesson: com.smartschedule.domain.models.Lesson,
        rand: Random
    ) {
        lesson.period = (lesson.period + rand.nextInt(3) - 1)
            .coerceIn(1, PERIODS_PER_DAY)
        lesson.dayOfWeek = (lesson.dayOfWeek + rand.nextInt(3) - 1)
            .coerceIn(1, DAYS_PER_WEEK)
    }
}

/**
 * بيانات تقدم عملية التوليد
 */
data class GenerationProgress(
    val currentGeneration: Int = 0,
    val maxGenerations: Int = 0,
    val bestFitness: Double = 0.0,
    val currentStep: String = "",
    val isCompleted: Boolean = false
)
```

=== file: app/src/main/java/com/smartschedule/presentation/viewmodel/ManageTeachersViewModel.kt ===
package com.smartschedule.presentation.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.smartschedule.data.database.entities.Teacher
import com.smartschedule.domain.repository.TimetableRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch
import javax.inject.Inject

data class TeachersUiState(
    val teachers: List<Teacher> = emptyList(),
    val isLoading: Boolean = true,
    val error: String? = null
)

@HiltViewModel
class ManageTeachersViewModel @Inject constructor(
    private val repository: TimetableRepository
) : ViewModel() {
    private val _uiState = MutableStateFlow(TeachersUiState())
    val uiState = _uiState.asStateFlow()

    init {
        loadTeachers()
    }

    private fun loadTeachers() {
        viewModelScope.launch {
            repository.getAllTeachers()
                .catch { error ->
                    _uiState.update { it.copy(error = error.message, isLoading = false) }
                }
                .collect { teachersList ->
                    _uiState.update { it.copy(teachers = teachersList, isLoading = false) }
                }
        }
    }

    fun addTeacher(teacher: Teacher) = viewModelScope.launch {
        try {
            repository.insertTeacher(teacher)
        } catch (e: Exception) {
            _uiState.update { it.copy(error = "Failed to add teacher: ${e.message}") }
        }
    }

    fun editTeacher(teacher: Teacher) = viewModelScope.launch {
        try {
            repository.updateTeacher(teacher)
        } catch (e: Exception) {
            _uiState.update { it.copy(error = "Failed to update teacher: ${e.message}") }
        }
    }

    fun deleteTeacher(teacher: Teacher) = viewModelScope.launch {
        try {
            repository.deleteTeacher(teacher)
        } catch (e: Exception) {
            _uiState.update { it.copy(error = "Failed to delete teacher: ${e.message}") }
        }
    }

    fun clearError() {
        _uiState.update { it.copy(error = null) }
    }
}

=== file: app/src/main/java/com/smartschedule/presentation/viewmodel/ManageSubjectsViewModel.kt ===
package com.smartschedule.presentation.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.smartschedule.data.database.entities.Subject
import com.smartschedule.data.database.entities.SubjectWithTeachers
import com.smartschedule.data.database.entities.Teacher
import com.smartschedule.domain.repository.TimetableRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch
import javax.inject.Inject

data class ManageSubjectsUiState(
    val subjectsWithTeachers: List<SubjectWithTeachers> = emptyList(),
    val allTeachers: List<Teacher> = emptyList(),
    val isLoading: Boolean = true,
    val error: String? = null
)

@HiltViewModel
class ManageSubjectsViewModel @Inject constructor(
    private val repository: TimetableRepository
) : ViewModel() {
    private val _uiState = MutableStateFlow(ManageSubjectsUiState())
    val uiState = _uiState.asStateFlow()

    init {
        loadData()
    }

    private fun loadData() {
        viewModelScope.launch {
            repository.getSubjectsWithTeachers()
                .combine(repository.getAllTeachers()) { subjects, teachers ->
                    ManageSubjectsUiState(
                        subjectsWithTeachers = subjects,
                        allTeachers = teachers,
                        isLoading = false
                    )
                }
                .catch { error ->
                    _uiState.update { it.copy(error = error.message, isLoading = false) }
                }
                .collect { state ->
                    _uiState.value = state
                }
        }
    }

    fun addSubject(subject: Subject, selectedTeacherIds: Set<String>) = viewModelScope.launch {
        try {
            repository.insertSubject(subject)
            selectedTeacherIds.forEach { teacherId ->
                repository.assignTeacherToSubject(teacherId, subject.id)
            }
        } catch (e: Exception) {
            _uiState.update { it.copy(error = "Failed to add subject: ${e.message}") }
        }
    }

    fun editSubject(subject: Subject) = viewModelScope.launch {
        try {
            repository.updateSubject(subject)
        } catch (e: Exception) {
            _uiState.update { it.copy(error = "Failed to update subject: ${e.message}") }
        }
    }

    fun deleteSubject(subject: Subject) = viewModelScope.launch {
        try {
            repository.deleteSubject(subject)
        } catch (e: Exception) {
            _uiState.update { it.copy(error = "Failed to delete subject: ${e.message}") }
        }
    }

    fun clearError() {
        _uiState.update { it.copy(error = null) }
    }
}

=== file: app/src/main/java/com/smartschedule/presentation/viewmodel/ManageClassesViewModel.kt ===
package com.smartschedule.presentation.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.smartschedule.data.database.entities.SchoolClass
import com.smartschedule.domain.repository.TimetableRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch
import javax.inject.Inject

data class ClassesUiState(
    val classes: List<SchoolClass> = emptyList(),
    val isLoading: Boolean = true,
    val error: String? = null
)

@HiltViewModel
class ManageClassesViewModel @Inject constructor(
    private val repository: TimetableRepository
) : ViewModel() {
    private val _uiState = MutableStateFlow(ClassesUiState())
    val uiState = _uiState.asStateFlow()

    init {
        loadClasses()
    }

    private fun loadClasses() {
        viewModelScope.launch {
            repository.getAllClasses()
                .catch { error ->
                    _uiState.update { it.copy(error = error.message, isLoading = false) }
                }
                .collect { classList ->
                    _uiState.update { it.copy(classes = classList, isLoading = false) }
                }
        }
    }

    fun addClass(schoolClass: SchoolClass) = viewModelScope.launch {
        try {
            repository.insertClass(schoolClass)
        } catch (e: Exception) {
            _uiState.update { it.copy(error = "Failed to add class: ${e.message}") }
        }
    }

    fun editClass(schoolClass: SchoolClass) = viewModelScope.launch {
        try {
            repository.updateClass(schoolClass)
        } catch (e: Exception) {
            _uiState.update { it.copy(error = "Failed to update class: ${e.message}") }
        }
    }

    fun deleteClass(schoolClass: SchoolClass) = viewModelScope.launch {
        try {
            repository.deleteClass(schoolClass)
        } catch (e: Exception) {
            _uiState.update { it.copy(error = "Failed to delete class: ${e.message}") }
        }
    }

    fun clearError() {
        _uiState.update { it.copy(error = null) }
    }
}

=== file: app/src/main/java/com/smartschedule/presentation/viewmodel/MainViewModel.kt ===
package com.smartschedule.presentation.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.smartschedule.domain.repository.TimetableRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch
import javax.inject.Inject

data class MainUiState(
    val totalClasses: Int = 0,
    val totalTeachers: Int = 0,
    val totalSubjects: Int = 0,
    val totalRooms: Int = 0,
    val totalLessons: Int = 0,
    val isLoading: Boolean = true,
    val error: String? = null
)

@HiltViewModel
class MainViewModel @Inject constructor(
    private val repository: TimetableRepository
) : ViewModel() {
    private val _uiState = MutableStateFlow(MainUiState())
    val uiState: StateFlow<MainUiState> = _uiState.asStateFlow()

    init {
        loadStatistics()
    }

    private fun loadStatistics() {
        viewModelScope.launch {
            combine(
                repository.getAllClasses(),
                repository.getAllTeachers(),
                repository.getAllSubjects(),
                repository.getAllRooms(),
                repository.getAllLessons()
            ) { classes, teachers, subjects, rooms, lessons ->
                MainUiState(
                    totalClasses = classes.size,
                    totalTeachers = teachers.size,
                    totalSubjects = subjects.size,
                    totalRooms = rooms.size,
                    totalLessons = lessons.size,
                    isLoading = false
                )
            }
            .catch { error ->
                _uiState.update { it.copy(error = error.message, isLoading = false) }
            }
            .collect {
                _uiState.value = it
            }
        }
    }

    fun refreshStatistics() {
        loadStatistics()
    }

    fun clearError() {
        _uiState.update { it.copy(error = null) }
    }
}

=== file: app/src/main/java/com/smartschedule/presentation/viewmodel/GenerateViewModel.kt ===
package com.smartschedule.presentation.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.smartschedule.domain.usecase.GenerateTimetableUseCase
import com.smartschedule.utils.algorithms.GeneticAlgorithmEngine
import com.smartschedule.utils.algorithms.GenerationProgress
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch
import javax.inject.Inject

data class GenerateUiState(
    val isGenerating: Boolean = false,
    val progress: GenerationProgress = GenerationProgress(),
    val showSuccessDialog: Boolean = false,
    val errorMessage: String? = null,
    val validationIssues: List<String> = emptyList()
)

@HiltViewModel
class GenerateViewModel @Inject constructor(
    private val generateUseCase: GenerateTimetableUseCase,
    private val engine: GeneticAlgorithmEngine
) : ViewModel() {
    private val _uiState = MutableStateFlow(GenerateUiState())
    val uiState = _uiState.asStateFlow()

    init {
        viewModelScope.launch {
            engine.progress.collect { prog ->
                _uiState.update { it.copy(progress = prog) }
            }
        }
    }

    fun startGeneration() = viewModelScope.launch {
        _uiState.update { 
            it.copy(
                isGenerating = true,
                progress = GenerationProgress(currentStep = "Starting generation...")
            ) 
        }
        try {
            val result = generateUseCase.execute()
            result.fold(
                onSuccess = {
                    _uiState.update { 
                        it.copy(
                            isGenerating = false,
                            showSuccessDialog = true,
                            progress = GenerationProgress(
                                currentStep = "Completed successfully!",
                                isCompleted = true
                            )
                        ) 
                    }
                },
                onFailure = { error ->
                    _uiState.update { 
                        it.copy(
                            isGenerating = false,
                            errorMessage = error.message ?: "Generation failed"
                        ) 
                    }
                }
            )
        } catch (e: Exception) {
            _uiState.update { 
                it.copy(
                    isGenerating = false,
                    errorMessage = e.message ?: "Unexpected error occurred"
                ) 
            }
        }
    }

    fun cancelGeneration() = viewModelScope.launch {
        engine.cancel()
        _uiState.update { 
            it.copy(
                isGenerating = false,
                progress = GenerationProgress(
                    currentStep = "Generation cancelled",
                    isCompleted = true
                )
            ) 
        }
    }

    fun dismissSuccessDialog() {
        _uiState.update { it.copy(showSuccessDialog = false) }
    }

    fun dismissError() {
        _uiState.update { it.copy(errorMessage = null) }
    }
}

=== file: app/src/main/java/com/smartschedule/presentation/viewmodel/ViewTimetableViewModel.kt ===
package com.smartschedule.presentation.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.smartschedule.data.database.entities.LessonEntity
import com.smartschedule.domain.repository.TimetableRepository
import com.smartschedule.domain.usecase.ExportTimetableUseCase
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch
import javax.inject.Inject

data class ViewTimetableUiState(
    val lessons: List<LessonEntity> = emptyList(),
    val isLoading: Boolean = true,
    val error: String? = null,
    val exportInProgress: Boolean = false,
    val exportSuccess: Boolean = false,
    val exportError: String? = null
)

@HiltViewModel
class ViewTimetableViewModel @Inject constructor(
    private val repository: TimetableRepository,
    private val exportUseCase: ExportTimetableUseCase
) : ViewModel() {
    private val _uiState = MutableStateFlow(ViewTimetableUiState())
    val uiState = _uiState.asStateFlow()

    init {
        loadLessons()
    }

    private fun loadLessons() {
        viewModelScope.launch {
            repository.getAllLessons()
                .catch { error ->
                    _uiState.update { it.copy(error = error.message, isLoading = false) }
                }
                .collect { lessons ->
                    _uiState.update { it.copy(lessons = lessons, isLoading = false) }
                }
        }
    }

    fun exportToPdf(context: android.content.Context, className: String) = viewModelScope.launch {
        _uiState.update { it.copy(exportInProgress = true, exportError = null) }
        try {
            val currentTimetable = repository.getCurrentTimetable()
            if (currentTimetable != null) {
                val file = exportUseCase.exportToPdf(context, currentTimetable, className)
                if (file != null) {
                    _uiState.update { 
                        it.copy(
                            exportInProgress = false,
                            exportSuccess = true
                        ) 
                    }
                } else {
                    _uiState.update { 
                        it.copy(
                            exportInProgress = false,
                            exportError = "Failed to create PDF file"
                        ) 
                    }
                }
            } else {
                _uiState.update { 
                    it.copy(
                        exportInProgress = false,
                        exportError = "No timetable available to export"
                    ) 
                }
            }
        } catch (e: Exception) {
            _uiState.update { 
                it.copy(
                    exportInProgress = false,
                    exportError = "Export failed: ${e.message}"
                ) 
            }
        }
    }

    fun clearExportStatus() {
        _uiState.update { 
            it.copy(
                exportSuccess = false,
                exportError = null
            ) 
        }
    }

    fun clearError() {
        _uiState.update { it.copy(error = null) }
    }
}

=== file: app/src/main/java/com/smartschedule/presentation/ui/screens/MainScreen.kt ===
package com.smartschedule.presentation.ui.screens

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyRow
import androidx.compose.foundation.lazy.grid.GridCells
import androidx.compose.foundation.lazy.grid.LazyVerticalGrid
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.navigation.NavController
import com.smartschedule.presentation.viewmodel.MainViewModel

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun MainScreen(
    navController: NavController,
    viewModel: MainViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsState()

    // Handle errors
    LaunchedEffect(uiState.error) {
        uiState.error?.let { error ->
            // Could show a snackbar here
            println("Error: $error")
        }
    }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp)
    ) {
        // Header
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.SpaceBetween,
            verticalAlignment = Alignment.CenterVertically
        ) {
            Text(
                text = "SmartSchedule",
                style = MaterialTheme.typography.headlineMedium,
                fontWeight = FontWeight.Bold
            )
            
            IconButton(onClick = { /* TODO: Navigate to settings */ }) {
                Icon(Icons.Default.Settings, contentDescription = "Settings")
            }
        }

        Spacer(modifier = Modifier.height(16.dp))

        if (uiState.isLoading) {
            Box(
                modifier = Modifier.fillMaxSize(),
                contentAlignment = Alignment.Center
            ) {
                CircularProgressIndicator()
            }
        } else {
            // Statistics Cards
            LazyRow(
                horizontalArrangement = Arrangement.spacedBy(12.dp),
                modifier = Modifier.padding(vertical = 16.dp)
            ) {
                item {
                    StatsCard(
                        title = "الفصول الدراسية",
                        value = uiState.totalClasses.toString(),
                        icon = Icons.Default.School,
                        color = MaterialTheme.colorScheme.primary
                    )
                }
                item {
                    StatsCard(
                        title = "المدرسون",
                        value = uiState.totalTeachers.toString(),
                        icon = Icons.Default.Person,
                        color = MaterialTheme.colorScheme.secondary
                    )
                }
                item {
                    StatsCard(
                        title = "المواد الدراسية",
                        value = uiState.totalSubjects.toString(),
                        icon = Icons.Default.Book,
                        color = MaterialTheme.colorScheme.tertiary
                    )
                }
                item {
                    StatsCard(
                        title = "الحصص",
                        value = uiState.totalLessons.toString(),
                        icon = Icons.Default.Schedule,
                        color = MaterialTheme.colorScheme.primary
                    )
                }
            }
            
            // Action Cards
            LazyVerticalGrid(
                columns = GridCells.Fixed(2),
                verticalArrangement = Arrangement.spacedBy(12.dp),
                horizontalArrangement = Arrangement.spacedBy(12.dp),
                modifier = Modifier.weight(1f)
            ) {
                item {
                    ActionCard(
                        title = "عرض الجدول",
                        subtitle = "عرض الجدول الحالي",
                        icon = Icons.Default.CalendarToday,
                        onClick = { navController.navigate("view_timetable") }
                    )
                }
                item {
                    ActionCard(
                        title = "إنشاء جدول",
                        subtitle = "توليد جدول جديد",
                        icon = Icons.Default.AutoAwesome,
                        onClick = { navController.navigate("generate") }
                    )
                }
                item {
                    ActionCard(
                        title = "إدارة المواد",
                        subtitle = "المواد والمدرسون",
                        icon = Icons.Default.ManageAccounts,
                        onClick = { navController.navigate("manage_subjects") }
                    )
                }
                item {
                    ActionCard(
                        title = "إدارة المدرسين",
                        subtitle = "إضافة وتعديل المدرسين",
                        icon = Icons.Default.Person,
                        onClick = { navController.navigate("manage_teachers") }
                    )
                }
                item {
                    ActionCard(
                        title = "إدارة الفصول",
                        subtitle = "الفصول الدراسية",
                        icon = Icons.Default.Groups,
                        onClick = { navController.navigate("manage_classes") }
                    )
                }
                item {
                    ActionCard(
                        title = "الإحصائيات",
                        subtitle = "تقارير وأداء",
                        icon = Icons.Default.Analytics,
                        onClick = { navController.navigate("reports") }
                    )
                }
            }
        }
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun StatsCard(
    title: String,
    value: String,
    icon: ImageVector,
    color: androidx.compose.ui.graphics.Color,
    modifier: Modifier = Modifier
) {
    Card(
        modifier = modifier.width(160.dp),
        colors = CardDefaults.cardColors(containerColor = color.copy(alpha = 0.1f))
    ) {
        Column(
            modifier = Modifier.padding(16.dp),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            Icon(
                imageVector = icon,
                contentDescription = title,
                tint = color,
                modifier = Modifier.size(32.dp)
            )
            Spacer(modifier = Modifier.height(8.dp))
            Text(
                text = value,
                style = MaterialTheme.typography.headlineMedium,
                fontWeight = FontWeight.Bold,
                color = color
            )
            Text(
                text = title,
                style = MaterialTheme.typography.bodyMedium
            )
        }
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun ActionCard(
    title: String,
    subtitle: String,
    icon: ImageVector,
    onClick: () -> Unit,
    modifier: Modifier = Modifier
) {
    Card(
        onClick = onClick,
        modifier = modifier.fillMaxWidth()
    ) {
        Column(
            modifier = Modifier.padding(16.dp),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            Icon(
                imageVector = icon,
                contentDescription = title,
                modifier = Modifier.size(48.dp),
                tint = MaterialTheme.colorScheme.primary
            )
            Spacer(modifier = Modifier.height(12.dp))
            Text(
                text = title,
                style = MaterialTheme.typography.titleMedium,
                fontWeight = FontWeight.Bold
            )
            Text(
                text = subtitle,
                style = MaterialTheme.typography.bodySmall,
                color = MaterialTheme.colorScheme.onSurfaceVariant
            )
        }
    }
}

=== file: app/src/main/java/com/smartschedule/presentation/ui/screens/ManageSubjectsScreen.kt ===
package com.smartschedule.presentation.ui.screens

import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.navigation.NavController
import com.smartschedule.data.database.entities.Subject
import com.smartschedule.data.database.entities.SubjectWithTeachers
import com.smartschedule.data.database.entities.Teacher
import com.smartschedule.presentation.viewmodel.ManageSubjectsViewModel

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun ManageSubjectsScreen(
    navController: NavController,
    viewModel: ManageSubjectsViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsState()
    var showAddDialog by remember { mutableStateOf(false) }

    // Handle errors
    LaunchedEffect(uiState.error) {
        uiState.error?.let { error ->
            // Show snackbar or handle error
            println("Error: $error")
        }
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("إدارة المواد الدراسية") },
                navigationIcon = {
                    IconButton(onClick = { navController.navigateUp() }) {
                        Icon(Icons.Default.ArrowBack, contentDescription = "رجوع")
                    }
                },
                actions = {
                    IconButton(onClick = { showAddDialog = true }) {
                        Icon(Icons.Default.Add, contentDescription = "إضافة مادة جديدة")
                    }
                }
            )
        }
    ) { paddingValues ->
        Box(modifier = Modifier.padding(paddingValues).fillMaxSize()) {
            if (uiState.isLoading) {
                CircularProgressIndicator(modifier = Modifier.align(Alignment.Center))
            } else if (uiState.subjectsWithTeachers.isEmpty()) {
                EmptyStateCard(
                    title = "لا توجد مواد دراسية",
                    subtitle = "انقر على + لإضافة مادة جديدة",
                    icon = Icons.Default.School,
                    modifier = Modifier.align(Alignment.Center)
                )
            } else {
                LazyColumn(
                    contentPadding = PaddingValues(16.dp),
                    verticalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    items(uiState.subjectsWithTeachers) { subjectWithTeachers ->
                        SubjectCard(
                            subjectWithTeachers = subjectWithTeachers,
                            onEdit = { viewModel.editSubject(it) },
                            onDelete = { viewModel.deleteSubject(it) }
                        )
                    }
                }
            }
        }
    }

    if (showAddDialog) {
        AddSubjectDialog(
            allTeachers = uiState.allTeachers,
            onDismiss = { showAddDialog = false },
            onAdd = { subject, teacherIds ->
                viewModel.addSubject(subject, teacherIds)
                showAddDialog = false
            }
        )
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun SubjectCard(
    subjectWithTeachers: SubjectWithTeachers,
    onEdit: (Subject) -> Unit,
    onDelete: (Subject) -> Unit
) {
    val subject = subjectWithTeachers.subject
    val teachers = subjectWithTeachers.teachers
    var showDeleteDialog by remember { mutableStateOf(false) }
    
    Card(
        modifier = Modifier.fillMaxWidth(),
        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)
    ) {
        Column(
            modifier = Modifier.padding(16.dp)
        ) {
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.Top
            ) {
                Column(modifier = Modifier.weight(1f)) {
                    Text(
                        text = subject.name,
                        style = MaterialTheme.typography.titleLarge,
                        fontWeight = FontWeight.Bold
                    )
                    Text(
                        text = "الرمز: ${subject.shortName}",
                        style = MaterialTheme.typography.bodyMedium,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                    Text(
                        text = "الساعات المعتمدة: ${subject.credits}",
                        style = MaterialTheme.typography.bodyMedium,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                    Text(
                        text = "القسم: ${subject.department}",
                        style = MaterialTheme.typography.bodyMedium,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                    
                    if (teachers.isNotEmpty()) {
                        Spacer(modifier = Modifier.height(8.dp))
                        Text(
                            text = "المدرسون: ${teachers.joinToString { "${it.firstName} ${it.lastName}" }}",
                            style = MaterialTheme.typography.bodySmall,
                            color = MaterialTheme.colorScheme.primary
                        )
                    }
                }
                
                // Color indicator
                Card(
                    modifier = Modifier.size(24.dp),
                    colors = CardDefaults.cardColors(
                        containerColor = Color(android.graphics.Color.parseColor(subject.color))
                    )
                ) {}
            }
            
            Spacer(modifier = Modifier.height(8.dp))
            
            Row(
                horizontalArrangement = Arrangement.End,
                modifier = Modifier.fillMaxWidth()
            ) {
                TextButton(onClick = { onEdit(subject) }) {
                    Icon(
                        Icons.Default.Edit,
                        contentDescription = null,
                        modifier = Modifier.size(16.dp)
                    )
                    Spacer(modifier = Modifier.width(4.dp))
                    Text("تعديل")
                }
                
                TextButton(
                    onClick = { showDeleteDialog = true },
                    colors = ButtonDefaults.textButtonColors(
                        contentColor = MaterialTheme.colorScheme.error
                    )
                ) {
                    Icon(
                        Icons.Default.Delete,
                        contentDescription = null,
                        modifier = Modifier.size(16.dp)
                    )
                    Spacer(modifier = Modifier.width(4.dp))
                    Text("حذف")
                }
            }
        }
    }
    
    if (showDeleteDialog) {
        AlertDialog(
            onDismissRequest = { showDeleteDialog = false },
            title = { Text("تأكيد الحذف") },
            text = { Text("هل أنت متأكد من حذف المادة \"${subject.name}\"؟") },
            confirmButton = {
                TextButton(
                    onClick = {
                        onDelete(subject)
                        showDeleteDialog = false
                    },
                    colors = ButtonDefaults.textButtonColors(
                        contentColor = MaterialTheme.colorScheme.error
                    )
                ) {
                    Text("حذف")
                }
            },
            dismissButton = {
                TextButton(onClick = { showDeleteDialog = false }) {
                    Text("إلغاء")
                }
            }
        )
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun AddSubjectDialog(
    allTeachers: List<Teacher>,
    onDismiss: () -> Unit,
    onAdd: (Subject, Set<String>) -> Unit
) {
    var name by remember { mutableStateOf("") }
    var shortName by remember { mutableStateOf("") }
    var credits by remember { mutableStateOf("") }
    var department by remember { mutableStateOf("") }
    var selectedColor by remember { mutableStateOf("#2196F3") }
    val selectedTeacherIds = remember { mutableStateOf(setOf<String>()) }
    
    val colors = listOf(
        "#2196F3", "#4CAF50", "#FF9800", "#F44336", 
        "#9C27B0", "#00BCD4", "#FFEB3B", "#607D8B"
    )
    
    AlertDialog(
        onDismissRequest = onDismiss,
        title = { Text("إضافة مادة دراسية جديدة") },
        text = {
            Column(
                modifier = Modifier.fillMaxWidth(),
                verticalArrangement = Arrangement.spacedBy(16.dp)
            ) {
                OutlinedTextField(
                    value = name,
                    onValueChange = { name = it },
                    label = { Text("اسم المادة") },
                    modifier = Modifier.fillMaxWidth()
                )
                
                OutlinedTextField(
                    value = shortName,
                    onValueChange = { shortName = it },
                    label = { Text("الرمز المختصر") },
                    modifier = Modifier.fillMaxWidth()
                )
                
                OutlinedTextField(
                    value = credits,
                    onValueChange = { credits = it },
                    label = { Text("عدد الساعات المعتمدة") },
                    modifier = Modifier.fillMaxWidth()
                )
                
                OutlinedTextField(
                    value = department,
                    onValueChange = { department = it },
                    label = { Text("القسم") },
                    modifier = Modifier.fillMaxWidth()
                )
                
                Text("لون المادة:", style = MaterialTheme.typography.bodyMedium)
                Row(
                    horizontalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    colors.forEach { color ->
                        Card(
                            modifier = Modifier
                                .size(32.dp)
                                .clickable { selectedColor = color },
                            colors = CardDefaults.cardColors(
                                containerColor = Color(android.graphics.Color.parseColor(color))
                            )
                        ) {
                            if (color == selectedColor) {
                                Box(
                                    modifier = Modifier.fillMaxSize(),
                                    contentAlignment = Alignment.Center
                                ) {
                                    Icon(
                                        Icons.Default.Check,
                                        contentDescription = null,
                                        modifier = Modifier.size(16.dp),
                                        tint = Color.White
                                    )
                                }
                            }
                        }
                    }
                }
                
                Text("اختر المدرسين لهذه المادة:", style = MaterialTheme.typography.bodyMedium)
                
                LazyColumn(
                    modifier = Modifier.heightIn(max = 200.dp)
                ) {
                    items(allTeachers) { teacher ->
                        Row(
                            verticalAlignment = Alignment.CenterVertically,
                            modifier = Modifier
                                .fillMaxWidth()
                                .clickable {
                                    val currentSelection = selectedTeacherIds.value.toMutableSet()
                                    if (teacher.id in currentSelection) {
                                        currentSelection.remove(teacher.id)
                                    } else {
                                        currentSelection.add(teacher.id)
                                    }
                                    selectedTeacherIds.value = currentSelection
                                }
                        ) {
                            Checkbox(
                                checked = teacher.id in selectedTeacherIds.value,
                                onCheckedChange = null
                            )
                            Spacer(modifier = Modifier.width(8.dp))
                            Text("${teacher.firstName} ${teacher.lastName}")
                        }
                    }
                }
            }
        },
        confirmButton = {
            Button(
                onClick = {
                    if (name.isNotBlank() && shortName.isNotBlank() && credits.isNotBlank()) {
                        val subject = Subject(
                            name = name.trim(),
                            shortName = shortName.trim().uppercase(),
                            credits = credits.toIntOrNull() ?: 1,
                            department = department.trim(),
                            color = selectedColor
                        )
                        onAdd(subject, selectedTeacherIds.value)
                    }
                },
                enabled = name.isNotBlank() && shortName.isNotBlank() && credits.isNotBlank()
            ) {
                Text("إضافة")
            }
        },
        dismissButton = {
            TextButton(onClick = onDismiss) {
                Text("إلغاء")
            }
        }
    )
}

@Composable
fun EmptyStateCard(
    title: String,
    subtitle: String,
    icon: androidx.compose.ui.graphics.vector.ImageVector,
    modifier: Modifier = Modifier
) {
    Card(
        modifier = modifier.padding(16.dp),
        colors = CardDefaults.cardColors(
            containerColor = MaterialTheme.colorScheme.surfaceVariant
        )
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(32.dp),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            Icon(
                icon,
                contentDescription = null,
                modifier = Modifier.size(64.dp),
                tint = MaterialTheme.colorScheme.primary
            )
            Spacer(modifier = Modifier.height(16.dp))
            Text(
                text = title,
                style = MaterialTheme.typography.titleMedium,
                color = MaterialTheme.colorScheme.onSurfaceVariant
            )
            Text(
                text = subtitle,
                style = MaterialTheme.typography.bodyMedium,
                color = MaterialTheme.colorScheme.onSurfaceVariant
            )
        }
    }
}

=== file: app/src/main/java/com/smartschedule/presentation/ui/screens/GenerateTimetableScreen.kt ===
package com.smartschedule.presentation.ui.screens

import androidx.compose.foundation.layout.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.navigation.NavController
import com.smartschedule.presentation.viewmodel.GenerateViewModel

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun GenerateTimetableScreen(
    navController: NavController,
    viewModel: GenerateViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsState()

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("إنشاء جدول جديد") },
                navigationIcon = {
                    IconButton(onClick = { navController.navigateUp() }) {
                        Icon(Icons.Default.ArrowBack, contentDescription = "رجوع")
                    }
                }
            )
        }
    ) { paddingValues ->
        Surface(
            modifier = Modifier
                .padding(paddingValues)
                .fillMaxSize()
        ) {
            Column(
                modifier = Modifier.padding(16.dp),
                horizontalAlignment = Alignment.CenterHorizontally
            ) {
                Text(
                    text = "إنشاء جدول جديد بالذكاء الاصطناعي",
                    style = MaterialTheme.typography.headlineSmall,
                    fontWeight = FontWeight.Bold,
                    modifier = Modifier.padding(vertical = 16.dp)
                )

                Spacer(modifier = Modifier.height(32.dp))

                if (uiState.isGenerating) {
                    CircularProgressIndicator(modifier = Modifier.size(64.dp))
                    Spacer(modifier = Modifier.height(24.dp))
                    Text(
                        text = uiState.progress.currentStep,
                        style = MaterialTheme.typography.bodyLarge
                    )
                    Spacer(modifier = Modifier.height(8.dp))
                    Text(
                        text = "الجيل: ${uiState.progress.currentGeneration}/${uiState.progress.maxGenerations}",
                        style = MaterialTheme.typography.bodyMedium
                    )
                    Text(
                        text = "أفضل لياقة: ${String.format("%.2f", uiState.progress.bestFitness * 100)}%",
                        style = MaterialTheme.typography.bodyMedium
                    )
                    Spacer(modifier = Modifier.height(24.dp))
                    Button(
                        onClick = { viewModel.cancelGeneration() },
                        colors = ButtonDefaults.buttonColors(
                            containerColor = MaterialTheme.colorScheme.error
                        )
                    ) {
                        Text("إلغاء العملية")
                    }
                } else {
                    Button(
                        onClick = { viewModel.startGeneration() },
                        modifier = Modifier.size(width = 200.dp, height = 60.dp)
                    ) {
                        Text(
                            text = "بدء الإنشاء",
                            style = MaterialTheme.typography.titleMedium
                        )
                    }

                    Spacer(modifier = Modifier.height(24.dp))

                    // Show previous progress if available
                    if (uiState.progress.currentGeneration > 0) {
                        Card(
                            modifier = Modifier.fillMaxWidth(),
                            colors = CardDefaults.cardColors(
                                containerColor = MaterialTheme.colorScheme.surfaceVariant
                            )
                        ) {
                            Column(
                                modifier = Modifier.padding(16.dp)
                            ) {
                                Text(
                                    text = "آخر عملية إنشاء",
                                    style = MaterialTheme.typography.titleMedium,
                                    fontWeight = FontWeight.Bold
                                )
                                Spacer(modifier = Modifier.height(8.dp))
                                Text("الحالة: ${uiState.progress.currentStep}")
                                Text("أفضل لياقة: ${String.format("%.2f", uiState.progress.bestFitness * 100)}%")
                            }
                        }
                    }
                }
            }
        }
    }

    // Success Dialog
    if (uiState.showSuccessDialog) {
        AlertDialog(
            onDismissRequest = { viewModel.dismissSuccessDialog() },
            title = { Text("تم الإنشاء بنجاح") },
            text = { Text("تم إنشاء الجدول الدراسي بنجاح! يمكنك الآن عرض الجدول من الصفحة الرئيسية.") },
            confirmButton = {
                Button(onClick = { 
                    viewModel.dismissSuccessDialog()
                    navController.navigateUp()
                }) {
                    Text("موافق")
                }
            }
        )
    }

    // Error Dialog
    uiState.errorMessage?.let { error ->
        AlertDialog(
            onDismissRequest = { viewModel.dismissError() },
            title = { Text("خطأ في الإنشاء") },
            text = { Text(error) },
            confirmButton = {
                Button(onClick = { viewModel.dismissError() }) {
                    Text("موافق")
                }
            }
        )
    }
}

=== file: app/src/main/java/com/smartschedule/presentation/ui/screens/ViewTimetableScreen.kt ===
package com.smartschedule.presentation.ui.screens

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material.icons.filled.Share
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.navigation.NavController
import com.smartschedule.data.database.entities.LessonEntity
import com.smartschedule.presentation.viewmodel.ViewTimetableViewModel

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun ViewTimetableScreen(
    navController: NavController,
    viewModel: ViewTimetableViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsState()

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("عرض الجدول الدراسي") },
                navigationIcon = {
                    IconButton(onClick = { navController.navigateUp() }) {
                        Icon(Icons.Default.ArrowBack, contentDescription = "رجوع")
                    }
                },
                actions = {
                    IconButton(
                        onClick = { 
                            // Export to PDF
                            viewModel.exportToPdf(
                                android.content.ContextWrapper(navController.context),
                                "Class Schedule"
                            )
                        },
                        enabled = !uiState.exportInProgress && uiState.lessons.isNotEmpty()
                    ) {
                        if (uiState.exportInProgress) {
                            CircularProgressIndicator(modifier = Modifier.size(24.dp))
                        } else {
                            Icon(Icons.Default.Share, contentDescription = "تصدير")
                        }
                    }
                }
            )
        }
    ) { paddingValues ->
        Box(modifier = Modifier.padding(paddingValues).fillMaxSize()) {
            when {
                uiState.isLoading -> {
                    CircularProgressIndicator(modifier = Modifier.align(Alignment.Center))
                }
                uiState.lessons.isEmpty() -> {
                    EmptyStateCard(
                        title = "لا توجد حصص مجدولة",
                        subtitle = "انتقل إلى إنشاء جدول جديد لبدء التخطيط",
                        icon = Icons.Default.Schedule,
                        modifier = Modifier.align(Alignment.Center)
                    )
                }
                else -> {
                    TimetableGrid(lessons = uiState.lessons)
                }
            }
        }
    }

    // Export success dialog
    if (uiState.exportSuccess) {
        AlertDialog(
            onDismissRequest = { viewModel.clearExportStatus() },
            title = { Text("تم التصدير بنجاح") },
            text = { Text("تم حفظ ملف PDF بنجاح في مجلد التطبيق") },
            confirmButton = {
                Button(onClick = { viewModel.clearExportStatus() }) {
                    Text("موافق")
                }
            }
        )
    }

    // Export error dialog
    uiState.exportError?.let { error ->
        AlertDialog(
            onDismissRequest = { viewModel.clearExportStatus() },
            title = { Text("خطأ في التصدير") },
            text = { Text(error) },
            confirmButton = {
                Button(onClick = { viewModel.clearExportStatus() }) {
                    Text("موافق")
                }
            }
        )
    }
}

@Composable
fun TimetableGrid(lessons: List<LessonEntity>) {
    val days = listOf("الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت")
    val periods = (1..8).toList()

    LazyColumn(
        modifier = Modifier.fillMaxSize(),
        verticalArrangement = Arrangement.spacedBy(1.dp)
    ) {
        // Header row
        item {
            Row(modifier = Modifier.background(MaterialTheme.colorScheme.primary)) {
                Box(
                    modifier = Modifier
                        .weight(1f)
                        .padding(8.dp),
                    contentAlignment = Alignment.Center
                ) {
                    Text(
                        text = "الفترة/اليوم",
                        color = Color.White,
                        fontWeight = FontWeight.Bold
                    )
                }
                days.forEach { day ->
                    Box(
                        modifier = Modifier
                            .weight(1f)
                            .padding(8.dp),
                        contentAlignment = Alignment.Center
                    ) {
                        Text(
                            text = day,
                            color = Color.White,
                            fontWeight = FontWeight.Bold
                        )
                    }
                }
            }
        }

        // Timetable rows
        items(periods) { period ->
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .height(80.dp)
            ) {
                // Period number
                Box(
                    modifier = Modifier
                        .weight(1f)
                        .background(MaterialTheme.colorScheme.secondaryContainer)
                        .padding(4.dp),
                    contentAlignment = Alignment.Center
                ) {
                    Text(
                        text = period.toString(),
                        fontWeight = FontWeight.Bold
                    )
                }

                // Lessons for each day
                days.forEachIndexed { dayIndex, _ ->
                    val dayLessons = lessons.filter { 
                        it.dayOfWeek == dayIndex + 1 && it.period == period 
                    }
                    Box(
                        modifier = Modifier
                            .weight(1f)
                            .background(Color.LightGray.copy(alpha = 0.2f))
                            .padding(4.dp)
                    ) {
                        dayLessons.forEach { lesson ->
                            LessonCard(lesson = lesson)
                        }
                    }
                }
            }
        }
    }
}

@Composable
fun LessonCard(lesson: LessonEntity) {
    Card(
        modifier = Modifier.fillMaxSize(),
        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
    ) {
        Column(
            modifier = Modifier.padding(4.dp)
        ) {
            Text(
                text = "مادة: ${lesson.subjectId?.take(8) ?: "N/A"}",
                style = MaterialTheme.typography.labelSmall,
                maxLines = 1
            )
            Text(
                text = "مدرس: ${lesson.teacherId?.take(6) ?: "N/A"}",
                style = MaterialTheme.typography.labelSmall,
                maxLines = 1
            )
            Text(
                text = "قاعة: ${lesson.roomId?.take(6) ?: "N/A"}",
                style = MaterialTheme.typography.labelSmall,
                maxLines = 1
            )
        }
    }
}

=== file: app/src/main/java/com/smartschedule/presentation/ui/screens/ManageTeachersScreen.kt ===
package com.smartschedule.presentation.ui.screens

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.navigation.NavController
import com.smartschedule.data.database.entities.Teacher
import com.smartschedule.presentation.viewmodel.ManageTeachersViewModel

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun ManageTeachersScreen(
    navController: NavController,
    viewModel: ManageTeachersViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsState()
    var showAddDialog by remember { mutableStateOf(false) }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("إدارة المدرسين") },
                navigationIcon = {
                    IconButton(onClick = { navController.navigateUp() }) {
                        Icon(Icons.Default.ArrowBack, contentDescription = "رجوع")
                    }
                },
                actions = {
                    IconButton(onClick = { showAddDialog = true }) {
                        Icon(Icons.Default.Add, contentDescription = "إضافة مدرس جديد")
                    }
                }
            )
        }
    ) { paddingValues ->
        Box(modifier = Modifier.padding(paddingValues).fillMaxSize()) {
            if (uiState.isLoading) {
                CircularProgressIndicator(modifier = Modifier.align(Alignment.Center))
            } else if (uiState.teachers.isEmpty()) {
                EmptyStateCard(
                    title = "لا يوجد مدرسون",
                    subtitle = "انقر على + لإضافة مدرس جديد",
                    icon = Icons.Default.Person,
                    modifier = Modifier.align(Alignment.Center)
                )
            } else {
                LazyColumn(
                    contentPadding = PaddingValues(16.dp),
                    verticalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    items(uiState.teachers) { teacher ->
                        TeacherCard(
                            teacher = teacher,
                            onEdit = { viewModel.editTeacher(it) },
                            onDelete = { viewModel.deleteTeacher(it) }
                        )
                    }
                }
            }
        }
    }

    if (showAddDialog) {
        AddTeacherDialog(
            onDismiss = { showAddDialog = false },
            onAdd = { teacher -> 
                viewModel.addTeacher(teacher)
                showAddDialog = false
            }
        )
    }
}

@Composable
fun TeacherCard(
    teacher: Teacher,
    onEdit: (Teacher) -> Unit,
    onDelete: (Teacher) -> Unit
) {
    var showDeleteDialog by remember { mutableStateOf(false) }
    
    Card(
        modifier = Modifier.fillMaxWidth(),
        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)
    ) {
        Column(
            modifier = Modifier.padding(16.dp)
        ) {
            Text(
                text = "${teacher.firstName} ${teacher.lastName}",
                style = MaterialTheme.typography.titleLarge,
                fontWeight = FontWeight.Bold
            )
            Text(
                text = "البريد الإلكتروني: ${teacher.email}",
                style = MaterialTheme.typography.bodyMedium,
                color = MaterialTheme.colorScheme.onSurfaceVariant
            )
            Text(
                text = "الهاتف: ${teacher.phone}",
                style = MaterialTheme.typography.bodyMedium,
                color = MaterialTheme.colorScheme.onSurfaceVariant
            )
            Text(
                text = "الحد الأقصى للساعات: ${teacher.maxHoursPerWeek}",
                style = MaterialTheme.typography.bodyMedium,
                color = MaterialTheme.colorScheme.onSurfaceVariant
            )
            
            Spacer(modifier = Modifier.height(8.dp))
            
            Row(
                horizontalArrangement = Arrangement.End,
                modifier = Modifier.fillMaxWidth()
            ) {
                TextButton(onClick = { onEdit(teacher) }) {
                    Icon(Icons.Default.Edit, contentDescription = null, modifier = Modifier.size(16.dp))
                    Spacer(modifier = Modifier.width(4.dp))
                    Text("تعديل")
                }
                
                TextButton(
                    onClick = { showDeleteDialog = true },
                    colors = ButtonDefaults.textButtonColors(contentColor = MaterialTheme.colorScheme.error)
                ) {
                    Icon(Icons.Default.Delete, contentDescription = null, modifier = Modifier.size(16.dp))
                    Spacer(modifier = Modifier.width(4.dp))
                    Text("حذف")
                }
            }
        }
    }
    
    if (showDeleteDialog) {
        AlertDialog(
            onDismissRequest = { showDeleteDialog = false },
            title = { Text("تأكيد الحذف") },
            text = { Text("هل أنت متأكد من حذف المدرس \"${teacher.firstName} ${teacher.lastName}\"؟") },
            confirmButton = {
                TextButton(
                    onClick = {
                        onDelete(teacher)
                        showDeleteDialog = false
                    },
                    colors = ButtonDefaults.textButtonColors(contentColor = MaterialTheme.colorScheme.error)
                ) {
                    Text("حذف")
                }
            },
            dismissButton = {
                TextButton(onClick = { showDeleteDialog = false }) {
                    Text("إلغاء")
                }
            }
        )
    }
}

@Composable
fun AddTeacherDialog(
    onDismiss: () -> Unit,
    onAdd: (Teacher) -> Unit
) {
    var firstName by remember { mutableStateOf("") }
    var lastName by remember { mutableStateOf("") }
    var email by remember { mutableStateOf("") }
    var phone by remember { mutableStateOf("") }
    var maxHours by remember { mutableStateOf("") }
    
    AlertDialog(
        onDismissRequest = onDismiss,
        title = { Text("إضافة مدرس جديد") },
        text = {
            Column(
                modifier = Modifier.fillMaxWidth(),
                verticalArrangement = Arrangement.spacedBy(16.dp)
            ) {
                OutlinedTextField(
                    value = firstName,
                    onValueChange = { firstName = it },
                    label = { Text("الاسم الأول") },
                    modifier = Modifier.fillMaxWidth()
                )
                
                OutlinedTextField(
                    value = lastName,
                    onValueChange = { lastName = it },
                    label = { Text("الاسم الأخير") },
                    modifier = Modifier.fillMaxWidth()
                )
                
                OutlinedTextField(
                    value = email,
                    onValueChange = { email = it },
                    label = { Text("البريد الإلكتروني") },
                    modifier = Modifier.fillMaxWidth()
                )
                
                OutlinedTextField(
                    value = phone,
                    onValueChange = { phone = it },
                    label = { Text("رقم الهاتف") },
                    modifier = Modifier.fillMaxWidth()
                )
                
                OutlinedTextField(
                    value = maxHours,
                    onValueChange = { maxHours = it },
                    label = { Text("الحد الأقصى للساعات أسبوعياً") },
                    modifier = Modifier.fillMaxWidth()
                )
            }
        },
        confirmButton = {
            Button(
                onClick = {
                    if (firstName.isNotBlank() && lastName.isNotBlank()) {
                        val teacher = Teacher(
                            firstName = firstName.trim(),
                            lastName = lastName.trim(),
                            email = email.trim(),
                            phone = phone.trim(),
                            maxHoursPerWeek = maxHours.toIntOrNull() ?: 20
                        )
                        onAdd(teacher)
                    }
                },
                enabled = firstName.isNotBlank() && lastName.isNotBlank()
            ) {
                Text("إضافة")
            }
        },
        dismissButton = {
            TextButton(onClick = onDismiss) {
                Text("إلغاء")
            }
        }
    )
}

=== file: app/src/main/java/com/smartschedule/presentation/ui/screens/ManageClassesScreen.kt ===
package com.smartschedule.presentation.ui.screens

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.navigation.NavController
import com.smartschedule.data.database.entities.SchoolClass
import com.smartschedule.presentation.viewmodel.ManageClassesViewModel

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun ManageClassesScreen(
    navController: NavController,
    viewModel: ManageClassesViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsState()
    var showAddDialog by remember { mutableStateOf(false) }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("إدارة الفصول الدراسية") },
                navigationIcon = {
                    IconButton(onClick = { navController.navigateUp() }) {
                        Icon(Icons.Default.ArrowBack, contentDescription = "رجوع")
                    }
                },
                actions = {
                    IconButton(onClick = { showAddDialog = true }) {
                        Icon(Icons.Default.Add, contentDescription = "إضافة فصل جديد")
                    }
                }
            )
        }
    ) { paddingValues ->
        Box(modifier = Modifier.padding(paddingValues).fillMaxSize()) {
            if (uiState.isLoading) {
                CircularProgressIndicator(modifier = Modifier.align(Alignment.Center))
            } else if (uiState.classes.isEmpty()) {
                EmptyStateCard(
                    title = "لا توجد فصول دراسية",
                    subtitle = "انقر على + لإضافة فصل جديد",
                    icon = Icons.Default.Groups,
                    modifier = Modifier.align(Alignment.Center)
                )
            } else {
                LazyColumn(
                    contentPadding = PaddingValues(16.dp),
                    verticalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    items(uiState.classes) { schoolClass ->
                        ClassCard(
                            schoolClass = schoolClass,
                            onEdit = { viewModel.editClass(it) },
                            onDelete = { viewModel.deleteClass(it) }
                        )
                    }
                }
            }
        }
    }

    if (showAddDialog) {
        AddClassDialog(
            onDismiss = { showAddDialog = false },
            onAdd = { schoolClass -> 
                viewModel.addClass(schoolClass)
                showAddDialog = false
            }
        )
    }
}

@Composable
fun ClassCard(
    schoolClass: SchoolClass,
    onEdit: (SchoolClass) -> Unit,
    onDelete: (SchoolClass) -> Unit
) {
    var showDeleteDialog by remember { mutableStateOf(false) }
    
    Card(
        modifier = Modifier.fillMaxWidth(),
        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)
    ) {
        Column(
            modifier = Modifier.padding(16.dp)
        ) {
            Text(
                text = schoolClass.name,
                style = MaterialTheme.typography.titleLarge,
                fontWeight = FontWeight.Bold
            )
            Text(
                text = "الصف: ${schoolClass.grade} - القسم: ${schoolClass.section}",
                style = MaterialTheme.typography.bodyMedium,
                color = MaterialTheme.colorScheme.onSurfaceVariant
            )
            Text(
                text = "عدد الطلاب: ${schoolClass.studentsCount}",
                style = MaterialTheme.typography.bodyMedium,
                color = MaterialTheme.colorScheme.onSurfaceVariant
            )
            Text(
                text = "السنة الدراسية: ${schoolClass.academicYear}",
                style = MaterialTheme.typography.bodyMedium,
                color = MaterialTheme.colorScheme.onSurfaceVariant
            )
            
            Spacer(modifier = Modifier.height(8.dp))
            
            Row(
                horizontalArrangement = Arrangement.End,
                modifier = Modifier.fillMaxWidth()
            ) {
                TextButton(onClick = { onEdit(schoolClass) }) {
                    Icon(Icons.Default.Edit, contentDescription = null, modifier = Modifier.size(16.dp))
                    Spacer(modifier = Modifier.width(4.dp))
                    Text("تعديل")
                }
                
                TextButton(
                    onClick = { showDeleteDialog = true },
                    colors = ButtonDefaults.textButtonColors(contentColor = MaterialTheme.colorScheme.error)
                ) {
                    Icon(Icons.Default.Delete, contentDescription = null, modifier = Modifier.size(16.dp))
                    Spacer(modifier = Modifier.width(4.dp))
                    Text("حذف")
                }
            }
        }
    }
    
    if (showDeleteDialog) {
        AlertDialog(
            onDismissRequest = { showDeleteDialog = false },
            title = { Text("تأكيد الحذف") },
            text = { Text("هل أنت متأكد من حذف الفصل \"${schoolClass.name}\"؟") },
            confirmButton = {
                TextButton(
                    onClick = {
                        onDelete(schoolClass)
                        showDeleteDialog = false
                    },
                    colors = ButtonDefaults.textButtonColors(contentColor = MaterialTheme.colorScheme.error)
                ) {
                    Text("حذف")
                }
            },
            dismissButton = {
                TextButton(onClick = { showDeleteDialog = false }) {
                    Text("إلغاء")
                }
            }
        )
    }
}

@Composable
fun AddClassDialog(
    onDismiss: () -> Unit,
    onAdd: (SchoolClass) -> Unit
) {
    var name by remember { mutableStateOf("") }
    var grade by remember { mutableStateOf("") }
    var section by remember { mutableStateOf("") }
    var studentsCount by remember { mutableStateOf("") }
    var academicYear by remember { mutableStateOf("") }
    
    AlertDialog(
        onDismissRequest = onDismiss,
        title = { Text("إضافة فصل دراسي جديد") },
        text = {
            Column(
                modifier = Modifier.fillMaxWidth(),
                verticalArrangement = Arrangement.spacedBy(16.dp)
            ) {
                OutlinedTextField(
                    value = name,
                    onValueChange = { name = it },
                    label = { Text("اسم الفصل") },
                    modifier = Modifier.fillMaxWidth()
                )
                
                OutlinedTextField(
                    value = grade,
                    onValueChange = { grade = it },
                    label = { Text("الصف") },
                    modifier = Modifier.fillMaxWidth()
                )
                
                OutlinedTextField(
                    value = section,
                    onValueChange = { section = it },
                    label = { Text("القسم") },
                    modifier = Modifier.fillMaxWidth()
                )
                
                OutlinedTextField(
                    value = studentsCount,
                    onValueChange = { studentsCount = it },
                    label = { Text("عدد الطلاب") },
                    modifier = Modifier.fillMaxWidth()
                )
                
                OutlinedTextField(
                    value = academicYear,
                    onValueChange = { academicYear = it },
                    label = { Text("السنة الدراسية") },
                    modifier = Modifier.fillMaxWidth()
                )
            }
        },
        confirmButton = {
            Button(
                onClick = {
                    if (name.isNotBlank()) {
                        val schoolClass = SchoolClass(
                            name = name.trim(),
                            grade = grade.toIntOrNull() ?: 1,
                            section = section.trim(),
                            studentsCount = studentsCount.toIntOrNull() ?: 0,
                            academicYear = academicYear.trim()
                        )
                        onAdd(schoolClass)
                    }
                },
                enabled = name.isNotBlank()
            ) {
                Text("إضافة")
            }
        },
        dismissButton = {
            TextButton(onClick = onDismiss) {
                Text("إلغاء")
            }
        }
    )
}

=== file: app/src/main/java/com/smartschedule/presentation/navigation/AppNavigation.kt ===
package com.smartschedule.presentation.navigation

import androidx.compose.runtime.Composable
import androidx.navigation.NavHostController
import androidx.navigation.compose.NavHost
import androidx.navigation.compose.composable
import androidx.navigation.compose.rememberNavController
import com.smartschedule.presentation.ui.screens.*

@Composable
fun AppNavigation() {
    val navController = rememberNavController()
    
    NavHost(
        navController = navController,
        startDestination = "main"
    ) {
        composable("main") { 
            MainScreen(navController = navController) 
        }
        composable("generate") { 
            GenerateTimetableScreen(navController = navController) 
        }
        composable("view_timetable") { 
            ViewTimetableScreen(navController = navController) 
        }
        composable("manage_subjects") { 
            ManageSubjectsScreen(navController = navController) 
        }
        composable("manage_teachers") { 
            ManageTeachersScreen(navController = navController) 
        }
        composable("manage_classes") { 
            ManageClassesScreen(navController = navController) 
        }
    }
}

=== file: app/src/main/java/com/smartschedule/presentation/navigation/Destinations.kt ===
package com.smartschedule.presentation.navigation

object Destinations {
    const val MAIN = "main"
    const val GENERATE = "generate"
    const val VIEW_TIMETABLE = "view_timetable"
    const val MANAGE_SUBJECTS = "manage_subjects"
    const val MANAGE_TEACHERS = "manage_teachers"
    const val MANAGE_CLASSES = "manage_classes"
}

=== file: app/src/main/res/xml/file_paths.xml ===
<?xml version="1.0" encoding="utf-8"?>
<paths xmlns:android="http://schemas.android.com/apk/res/android">
    <external-files-path name="exports" path="exports/" />
    <cache-path name="cache" path="/" />
</paths>

=== file: app/src/main/res/xml/data_extraction_rules.xml ===
<?xml version="1.0" encoding="utf-8"?>
<data-extraction-rules>
    <cloud-backup>
        <include domain="file" path="exports/"/>
        <exclude domain="file" path="exports/temp/"/>
    </cloud-backup>
    <device-transfer>
        <include domain="file" path="exports/"/>
        <exclude domain="file" path="exports/temp/"/>
    </device-transfer>
</data-extraction-rules>

=== file: app/src/main/res/xml/backup_rules.xml ===
<?xml version="1.0" encoding="utf-8"?>
<full-backup-content>
    <include domain="file" path="exports/"/>
    <exclude domain="file" path="exports/temp/"/>
</full-backup-content>

=== file: app/src/test/java/com/smartschedule/GeneticAlgorithmTest.kt ===
package com.smartschedule

import com.smartschedule.data.database.entities.*
import com.smartschedule.utils.algorithms.GeneticAlgorithmEngine
import kotlinx.coroutines.test.runTest
import org.junit.Test
import kotlin.test.assertTrue

class GeneticAlgorithmTest {

    @Test
    fun testGeneticAlgorithmWithSampleData() = runTest {
        val engine = GeneticAlgorithmEngine()
        
        // Create sample data
        val subjects = listOf(
            Subject(name = "Math", shortName = "MATH", credits = 3),
            Subject(name = "Science", shortName = "SCI", credits = 3),
            Subject(name = "History", shortName = "HIS", credits = 2)
        )
        
        val teachers = listOf(
            Teacher(
                firstName = "John",
                lastName = "Doe",
                subjects = listOf(subjects[0].id, subjects[1].id)
            ),
            Teacher(
                firstName = "Jane",
                lastName = "Smith", 
                subjects = listOf(subjects[2].id)
            )
        )
        
        val classes = listOf(
            SchoolClass(name = "Grade 10-A", grade = 10, studentsCount = 30),
            SchoolClass(name = "Grade 10-B", grade = 10, studentsCount = 25)
        )
        
        val rooms = listOf(
            Room(name = "Room 101", capacity = 35),
            Room(name = "Room 102", capacity = 30),
            Room(name = "Lab 201", capacity = 20)
        )
        
        val result = engine.generate(subjects, teachers, classes, rooms)
        
        assertTrue(result != null, "Algorithm should generate a timetable")
        assertTrue(result!!.lessons.isNotEmpty(), "Timetable should have lessons")
        assertTrue(result.fitnessScore > 0, "Timetable should have positive fitness score")
    }

    @Test
    fun testGeneticAlgorithmWithInsufficientData() = runTest {
        val engine = GeneticAlgorithmEngine()
        
        // Test with empty data
        val result = engine.generate(emptyList(), emptyList(), emptyList(), emptyList())
        
        assertTrue(result == null, "Algorithm should return null with insufficient data")
    }
}

=== file: app/src/test/java/com/smartschedule/RepositoryTest.kt ===
package com.smartschedule

import app.cash.turbine.test
import com.smartschedule.data.database.entities.Subject
import com.smartschedule.data.repository.TimetableRepositoryImpl
import com.smartschedule.domain.repository.TimetableRepository
import kotlinx.coroutines.test.runTest
import org.junit.Test
import kotlin.test.assertEquals
import kotlin.test.assertTrue

class RepositoryTest {

    @Test
    fun testRepositoryOperations() = runTest {
        // This would typically use a test database
        // For now, we'll test the basic functionality
        
        val testSubject = Subject(
            name = "Test Subject",
            shortName = "TEST",
            credits = 3
        )
        
        // Test that we can create repository instance
        // In real test, we would use dependency injection with test modules
        assertTrue(true, "Repository should be testable with proper setup")
    }

    @Test
    fun testFlowOperations() = runTest {
        // Test that flows emit values correctly
        // This would require a test implementation of the DAOs
        
        assertTrue(true, "Flow operations should be testable with test doubles")
    }
}

=== file: app/src/main/java/com/smartschedule/ui/theme/Theme.kt ===
package com.smartschedule.ui.theme

import androidx.compose.material3.MaterialTheme
import androidx.compose.runtime.Composable

@Composable
fun SmartScheduleTheme(content: @Composable () -> Unit) {
    MaterialTheme(
        content = content
    )
}

```kotlin
=== file: app/src/main/java/com/smartschedule/domain/models/FitnessWeights.kt ===
package com.smartschedule.domain.models

data class FitnessWeights(
    val teacherConflict: Double = 0.15,
    val classConflict: Double = 0.15,
    val roomConflict: Double = 0.15,
    val teacherSubjectMismatch: Double = 0.12,
    val roomCapacityViolation: Double = 0.12,
    val distributionPenalty: Double = 0.08,
    val gapPenalty: Double = 0.06,
    val teacherLoadPenalty: Double = 0.05,
    val roomUtilizationPenalty: Double = 0.04
) {
    fun validate(): Boolean {
        val total = teacherConflict + classConflict + roomConflict + 
                   teacherSubjectMismatch + roomCapacityViolation +
                   distributionPenalty + gapPenalty + teacherLoadPenalty + roomUtilizationPenalty
        return total in 0.9..1.1
    }
}

=== file: app/src/main/java/com/smartschedule/presentation/ui/screens/FitnessWeightsScreen.kt ===
package com.smartschedule.presentation.ui.screens

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material.icons.filled.Save
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.navigation.NavController
import com.smartschedule.domain.models.FitnessWeights
import com.smartschedule.presentation.viewmodel.FitnessWeightsViewModel

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun FitnessWeightsScreen(
    navController: NavController,
    viewModel: FitnessWeightsViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsState()

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("إعدادات أوزان الجدولة") },
                navigationIcon = {
                    IconButton(onClick = { navController.navigateUp() }) {
                        Icon(Icons.Default.ArrowBack, contentDescription = "رجوع")
                    }
                },
                actions = {
                    IconButton(
                        onClick = { viewModel.saveWeights() },
                        enabled = uiState.weights.validate()
                    ) {
                        Icon(Icons.Default.Save, contentDescription = "حفظ")
                    }
                }
            )
        }
    ) { paddingValues ->
        LazyColumn(
            modifier = Modifier
                .padding(paddingValues)
                .fillMaxSize()
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            item {
                Text(
                    text = "ضبط أوزان معايير الجدولة",
                    style = MaterialTheme.typography.headlineSmall,
                    fontWeight = FontWeight.Bold
                )
                Text(
                    text = "مجموع الأوزان يجب أن يكون قريباً من 1.0",
                    style = MaterialTheme.typography.bodyMedium,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }

            item { WeightSlider("صراعات المدرسين", uiState.weights.teacherConflict) { 
                viewModel.updateWeights(uiState.weights.copy(teacherConflict = it)) 
            }}

            item { WeightSlider("صراعات الفصول", uiState.weights.classConflict) { 
                viewModel.updateWeights(uiState.weights.copy(classConflict = it)) 
            }}

            item { WeightSlider("صراعات القاعات", uiState.weights.roomConflict) { 
                viewModel.updateWeights(uiState.weights.copy(roomConflict = it)) 
            }}

            item { WeightSlider("عدم تطابق المدرس مع المادة", uiState.weights.teacherSubjectMismatch) { 
                viewModel.updateWeights(uiState.weights.copy(teacherSubjectMismatch = it)) 
            }}

            item { WeightSlider("تجاوز سعة القاعة", uiState.weights.roomCapacityViolation) { 
                viewModel.updateWeights(uiState.weights.copy(roomCapacityViolation = it)) 
            }}

            item { WeightSlider("توزيع الحصص", uiState.weights.distributionPenalty) { 
                viewModel.updateWeights(uiState.weights.copy(distributionPenalty = it)) 
            }}

            item { WeightSlider("الفجوات بين الحصص", uiState.weights.gapPenalty) { 
                viewModel.updateWeights(uiState.weights.copy(gapPenalty = it)) 
            }}

            item { WeightSlider("عبء العمل على المدرسين", uiState.weights.teacherLoadPenalty) { 
                viewModel.updateWeights(uiState.weights.copy(teacherLoadPenalty = it)) 
            }}

            item { WeightSlider("استخدام القاعات", uiState.weights.roomUtilizationPenalty) { 
                viewModel.updateWeights(uiState.weights.copy(roomUtilizationPenalty = it)) 
            }}

            item {
                val total = uiState.weights.teacherConflict + uiState.weights.classConflict +
                           uiState.weights.roomConflict + uiState.weights.teacherSubjectMismatch +
                           uiState.weights.roomCapacityViolation + uiState.weights.distributionPenalty +
                           uiState.weights.gapPenalty + uiState.weights.teacherLoadPenalty +
                           uiState.weights.roomUtilizationPenalty

                Card(
                    colors = CardDefaults.cardColors(
                        containerColor = if (uiState.weights.validate()) 
                            MaterialTheme.colorScheme.primaryContainer 
                        else 
                            MaterialTheme.colorScheme.errorContainer
                    )
                ) {
                    Column(
                        modifier = Modifier.padding(16.dp),
                        horizontalAlignment = Alignment.CenterHorizontally
                    ) {
                        Text(
                            text = "المجموع: ${String.format("%.2f", total)}",
                            style = MaterialTheme.typography.titleMedium,
                            fontWeight = FontWeight.Bold,
                            color = if (uiState.weights.validate()) 
                                MaterialTheme.colorScheme.onPrimaryContainer 
                            else 
                                MaterialTheme.colorScheme.onErrorContainer
                        )
                        if (!uiState.weights.validate()) {
                            Text(
                                text = "المجموع خارج النطاق المثالي (0.9 - 1.1)",
                                style = MaterialTheme.typography.bodySmall,
                                color = MaterialTheme.colorScheme.onErrorContainer
                            )
                        }
                    }
                }
            }
        }
    }

    if (uiState.showSaveSuccess) {
        AlertDialog(
            onDismissRequest = { viewModel.dismissSaveSuccess() },
            title = { Text("تم الحفظ") },
            text = { Text("تم حفظ الإعدادات بنجاح") },
            confirmButton = {
                Button(onClick = { 
                    viewModel.dismissSaveSuccess()
                    navController.navigateUp()
                }) {
                    Text("موافق")
                }
            }
        )
    }
}

@Composable
fun WeightSlider(
    title: String,
    value: Double,
    onValueChange: (Double) -> Unit
) {
    Card {
        Column(modifier = Modifier.padding(16.dp)) {
            Text(
                text = title,
                style = MaterialTheme.typography.titleMedium,
                fontWeight = FontWeight.Medium
            )
            Spacer(modifier = Modifier.height(8.dp))
            Row(verticalAlignment = Alignment.CenterVertically) {
                Text(
                    text = String.format("%.2f", value),
                    style = MaterialTheme.typography.bodyMedium,
                    modifier = Modifier.width(40.dp)
                )
                Spacer(modifier = Modifier.width(16.dp))
                Slider(
                    value = value.toFloat(),
                    onValueChange = { onValueChange(it.toDouble()) },
                    valueRange = 0f..0.3f,
                    modifier = Modifier.weight(1f)
                )
            }
        }
    }
}

=== file: app/src/main/java/com/smartschedule/presentation/viewmodel/FitnessWeightsViewModel.kt ===
package com.smartschedule.presentation.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.smartschedule.domain.models.FitnessWeights
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import javax.inject.Inject

data class FitnessWeightsUiState(
    val weights: FitnessWeights = FitnessWeights(),
    val showSaveSuccess: Boolean = false,
    val error: String? = null
)

@HiltViewModel
class FitnessWeightsViewModel @Inject constructor() : ViewModel() {
    private val _uiState = MutableStateFlow(FitnessWeightsUiState())
    val uiState: StateFlow<FitnessWeightsUiState> = _uiState.asStateFlow()

    fun updateWeights(weights: FitnessWeights) {
        _uiState.value = _uiState.value.copy(weights = weights)
    }

    fun saveWeights() {
        viewModelScope.launch {
            // TODO: Save to DataStore or SharedPreferences
            _uiState.value = _uiState.value.copy(showSaveSuccess = true)
        }
    }

    fun dismissSaveSuccess() {
        _uiState.value = _uiState.value.copy(showSaveSuccess = false)
    }
}

=== file: app/src/main/java/com/smartschedule/domain/usecase/ExportTimetableUseCase.kt ===
// UPDATED VERSION WITH MULTIPLE FORMATS
package com.smartschedule.domain.usecase

import android.content.Context
import android.graphics.Canvas
import android.graphics.Paint
import android.graphics.pdf.PdfDocument
import android.net.Uri
import androidx.core.content.FileProvider
import com.smartschedule.domain.models.Timetable
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.io.File
import java.io.FileOutputStream
import java.io.PrintWriter
import javax.inject.Inject

enum class ExportFormat { PDF, EXCEL, CSV }

class ExportTimetableUseCase @Inject constructor() {

    suspend fun exportTimetable(
        context: Context,
        timetable: Timetable,
        className: String,
        format: ExportFormat
    ): File? = withContext(Dispatchers.IO) {
        try {
            when (format) {
                ExportFormat.PDF -> exportToPdf(context, timetable, className)
                ExportFormat.EXCEL -> exportToExcel(context, timetable, className)
                ExportFormat.CSV -> exportToCsv(context, timetable, className)
            }
        } catch (e: Exception) {
            e.printStackTrace()
            null
        }
    }

    private fun exportToPdf(context: Context, timetable: Timetable, className: String): File? {
        val pageWidth = 595
        val pageHeight = 842
        val pdf = PdfDocument()
        val pageInfo = PdfDocument.PageInfo.Builder(pageWidth, pageHeight, 1).create()
        val page = pdf.startPage(pageInfo)
        val canvas: Canvas = page.canvas
        val paint = Paint().apply { 
            textSize = 12f
            isAntiAlias = true 
        }

        // Header
        paint.textSize = 18f
        paint.isFakeBoldText = true
        canvas.drawText("جدول الحصص - $className", 40f, 40f, paint)
        paint.textSize = 10f
        paint.isFakeBoldText = false

        // Table layout
        val startX = 40f
        var startY = 80f
        val cellHeight = 18f

        val days = listOf("الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت")
        canvas.drawText("الفترة", startX, startY, paint)
        days.forEachIndexed { idx, d -> 
            canvas.drawText(d, startX + (idx + 1) * 85f, startY, paint) 
        }
        startY += cellHeight

        val periods = (1..8)
        periods.forEach { p ->
            canvas.drawText("$p", startX, startY, paint)
            days.forEachIndexed { dayIdx, _ ->
                val lesson = timetable.lessons.find { 
                    it.dayOfWeek == dayIdx + 1 && it.period == p 
                }
                if (lesson != null) {
                    val text = "${lesson.subjectId?.take(8) ?: ""}\n${lesson.teacherId?.take(6) ?: ""}"
                    canvas.drawText(text, startX + (dayIdx + 1) * 85f, startY, paint)
                }
            }
            startY += cellHeight * 2
        }

        pdf.finishPage(page)
        val outDir = File(context.getExternalFilesDir(null), "exports")
        if (!outDir.exists()) outDir.mkdirs()
        val file = File(outDir, "timetable_${className}_${System.currentTimeMillis()}.pdf")
        FileOutputStream(file).use { pdf.writeTo(it) }
        pdf.close()
        return file
    }

    private fun exportToExcel(context: Context, timetable: Timetable, className: String): File? {
        val outDir = File(context.getExternalFilesDir(null), "exports")
        if (!outDir.exists()) outDir.mkdirs()
        val file = File(outDir, "timetable_${className}_${System.currentTimeMillis()}.csv")

        PrintWriter(file).use { writer ->
            // Header
            writer.println("الفترة,الإثنين,الثلاثاء,الأربعاء,الخميس,الجمعة,السبت")
            
            val periods = (1..8)
            periods.forEach { period ->
                val row = StringBuilder()
                row.append("$period,")
                
                val days = (1..6)
                days.forEach { day ->
                    val lesson = timetable.lessons.find { 
                        it.dayOfWeek == day && it.period == period 
                    }
                    row.append(if (lesson != null) {
                        "${lesson.subjectId} (${lesson.teacherId})"
                    } else {
                        ""
                    })
                    if (day < 6) row.append(",")
                }
                writer.println(row.toString())
            }
        }
        return file
    }

    private fun exportToCsv(context: Context, timetable: Timetable, className: String): File? {
        val outDir = File(context.getExternalFilesDir(null), "exports")
        if (!outDir.exists()) outDir.mkdirs()
        val file = File(outDir, "timetable_${className}_${System.currentTimeMillis()}.csv")

        PrintWriter(file).use { writer ->
            writer.println("اليوم,الفترة,المادة,المدرس,القاعة")
            timetable.lessons.forEach { lesson ->
                writer.println("${lesson.dayOfWeek},${lesson.period},${lesson.subjectId},${lesson.teacherId},${lesson.roomId}")
            }
        }
        return file
    }

    suspend fun getShareableUri(context: Context, file: File): Uri? = withContext(Dispatchers.IO) {
        try {
            FileProvider.getUriForFile(
                context,
                "com.smartschedule.fileprovider",
                file
            )
        } catch (e: Exception) {
            null
        }
    }
}

=== file: app/src/main/java/com/smartschedule/presentation/ui/screens/ExportDialog.kt ===
package com.smartschedule.presentation.ui.screens

import androidx.compose.foundation.layout.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.compose.ui.window.Dialog
import com.smartschedule.domain.usecase.ExportFormat

@Composable
fun ExportDialog(
    onDismiss: () -> Unit,
    onExport: (ExportFormat) -> Unit
) {
    Dialog(onDismissRequest = onDismiss) {
        Card(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp)
        ) {
            Column(
                modifier = Modifier.padding(16.dp)
            ) {
                Text(
                    text = "تصدير الجدول",
                    style = MaterialTheme.typography.headlineSmall,
                    fontWeight = FontWeight.Bold
                )
                
                Spacer(modifier = Modifier.height(16.dp))
                
                ExportOption(
                    title = "PDF",
                    description = "ملف PDF مناسب للطباعة",
                    icon = Icons.Default.PictureAsPdf,
                    onClick = { onExport(ExportFormat.PDF) }
                )
                
                ExportOption(
                    title = "Excel",
                    description = "ملف Excel للتحرير",
                    icon = Icons.Default.TableChart,
                    onClick = { onExport(ExportFormat.EXCEL) }
                )
                
                ExportOption(
                    title = "CSV", 
                    description = "ملف CSV للبيانات",
                    icon = Icons.Default.DataUsage,
                    onClick = { onExport(ExportFormat.CSV) }
                )
                
                Spacer(modifier = Modifier.height(16.dp))
                
                Button(
                    onClick = onDismiss,
                    modifier = Modifier.fillMaxWidth(),
                    colors = ButtonDefaults.buttonColors(
                        containerColor = MaterialTheme.colorScheme.surfaceVariant
                    )
                ) {
                    Text("إلغاء")
                }
            }
        }
    }
}

@Composable
fun ExportOption(
    title: String,
    description: String,
    icon: androidx.compose.ui.graphics.vector.ImageVector,
    onClick: () -> Unit
) {
    Card(
        onClick = onClick,
        modifier = Modifier
            .fillMaxWidth()
            .padding(vertical = 4.dp)
    ) {
        Row(
            modifier = Modifier.padding(16.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Icon(
                imageVector = icon,
                contentDescription = title,
                modifier = Modifier.size(32.dp),
                tint = MaterialTheme.colorScheme.primary
            )
            Spacer(modifier = Modifier.width(16.dp))
            Column {
                Text(
                    text = title,
                    style = MaterialTheme.typography.titleMedium,
                    fontWeight = FontWeight.Medium
                )
                Text(
                    text = description,
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }
        }
    }
}

=== file: app/src/main/java/com/smartschedule/utils/algorithms/HybridScheduler.kt ===
package com.smartschedule.utils.algorithms

import com.smartschedule.data.database.entities.*
import com.smartschedule.domain.models.Timetable
import kotlinx.coroutines.sync.Mutex
import kotlinx.coroutines.sync.withLock
import java.util.*
import kotlin.math.exp
import kotlin.random.Random

class HybridScheduler {
    
    private val geneticEngine = GeneticAlgorithmEngine()
    private val mutex = Mutex()
    
    suspend fun hybridSchedule(
        subjects: List<Subject>,
        teachers: List<Teacher>,
        classes: List<SchoolClass>,
        rooms: List<Room>,
        useReinforcement: Boolean = false
    ): Timetable? {
        return mutex.withLock {
            // Step 1: Use genetic algorithm for initial solution
            val geneticResult = geneticEngine.generate(subjects, teachers, classes, rooms)
            
            // Step 2: Apply local search optimization
            val optimized = geneticResult?.let { localSearchOptimization(it, subjects, teachers, classes, rooms) }
            
            // Step 3: Optional reinforcement learning refinement
            if (useReinforcement && optimized != null) {
                return@withLock reinforcementRefinement(optimized, subjects, teachers, classes, rooms)
            }
            
            return@withLock optimized
        }
    }
    
    private fun localSearchOptimization(
        timetable: Timetable,
        subjects: List<Subject>,
        teachers: List<Teacher>,
        classes: List<SchoolClass>,
        rooms: List<Room>
    ): Timetable {
        var current = timetable.copy()
        var improved = true
        val maxIterations = 100
        
        repeat(maxIterations) {
            if (!improved) return@repeat
            
            improved = false
            val neighbor = generateNeighbor(current, subjects, teachers, classes, rooms)
            
            if (neighbor.fitnessScore > current.fitnessScore) {
                current = neighbor
                improved = true
            }
        }
        
        return current
    }
    
    private fun generateNeighbor(
        timetable: Timetable,
        subjects: List<Subject>,
        teachers: List<Teacher>,
        classes: List<SchoolClass>,
        rooms: List<Room>
    ): Timetable {
        val neighbor = timetable.copy()
        val rand = Random(System.nanoTime())
        
        when (rand.nextInt(3)) {
            0 -> {
                // Swap two lessons
                val i1 = rand.nextInt(neighbor.lessons.size)
                val i2 = rand.nextInt(neighbor.lessons.size)
                val tempDay = neighbor.lessons[i1].dayOfWeek
                val tempPeriod = neighbor.lessons[i1].period
                neighbor.lessons[i1].dayOfWeek = neighbor.lessons[i2].dayOfWeek
                neighbor.lessons[i1].period = neighbor.lessons[i2].period
                neighbor.lessons[i2].dayOfWeek = tempDay
                neighbor.lessons[i2].period = tempPeriod
            }
            1 -> {
                // Move a lesson to random slot
                val lessonIndex = rand.nextInt(neighbor.lessons.size)
                neighbor.lessons[lessonIndex].dayOfWeek = rand.nextInt(6) + 1
                neighbor.lessons[lessonIndex].period = rand.nextInt(8) + 1
            }
            2 -> {
                // Change room for a lesson
                val lessonIndex = rand.nextInt(neighbor.lessons.size)
                val classSize = classes.find { it.id == neighbor.lessons[lessonIndex].classId }?.studentsCount ?: 0
                val suitableRooms = rooms.filter { it.capacity >= classSize }
                if (suitableRooms.isNotEmpty()) {
                    neighbor.lessons[lessonIndex].roomId = suitableRooms[rand.nextInt(suitableRooms.size)].id
                }
            }
        }
        
        return neighbor
    }
    
    private fun reinforcementRefinement(
        timetable: Timetable,
        subjects: List<Subject>,
        teachers: List<Teacher>,
        classes: List<SchoolClass>,
        rooms: List<Room>
    ): Timetable {
        // Simple Q-learning inspired refinement
        var bestTimetable = timetable.copy()
        val explorationRate = 0.1
        val learningRate = 0.1
        
        repeat(50) { episode ->
            val current = if (Random.nextDouble() < explorationRate) {
                generateNeighbor(bestTimetable, subjects, teachers, classes, rooms)
            } else {
                bestTimetable.copy()
            }
            
            // Evaluate improvement
            if (current.fitnessScore > bestTimetable.fitnessScore) {
                bestTimetable = current
            }
        }
        
        return bestTimetable
    }
}

=== file: app/src/main/java/com/smartschedule/presentation/ui/screens/ViewTimetableScreen.kt ===
// UPDATED VERSION WITH EXPORT DIALOG
package com.smartschedule.presentation.ui.screens

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material.icons.filled.Share
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.navigation.NavController
import com.smartschedule.data.database.entities.LessonEntity
import com.smartschedule.domain.usecase.ExportFormat
import com.smartschedule.presentation.viewmodel.ViewTimetableViewModel

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun ViewTimetableScreen(
    navController: NavController,
    viewModel: ViewTimetableViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsState()
    var showExportDialog by remember { mutableStateOf(false) }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("عرض الجدول الدراسي") },
                navigationIcon = {
                    IconButton(onClick = { navController.navigateUp() }) {
                        Icon(Icons.Default.ArrowBack, contentDescription = "رجوع")
                    }
                },
                actions = {
                    IconButton(
                        onClick = { showExportDialog = true },
                        enabled = uiState.lessons.isNotEmpty() && !uiState.exportInProgress
                    ) {
                        if (uiState.exportInProgress) {
                            CircularProgressIndicator(modifier = Modifier.size(24.dp))
                        } else {
                            Icon(Icons.Default.Share, contentDescription = "تصدير")
                        }
                    }
                }
            )
        }
    ) { paddingValues ->
        Box(modifier = Modifier.padding(paddingValues).fillMaxSize()) {
            when {
                uiState.isLoading -> {
                    CircularProgressIndicator(modifier = Modifier.align(Alignment.Center))
                }
                uiState.lessons.isEmpty() -> {
                    EmptyStateCard(
                        title = "لا توجد حصص مجدولة",
                        subtitle = "انتقل إلى إنشاء جدول جديد لبدء التخطيط",
                        icon = Icons.Default.Schedule,
                        modifier = Modifier.align(Alignment.Center)
                    )
                }
                else -> {
                    TimetableGrid(lessons = uiState.lessons)
                }
            }
        }
    }

    if (showExportDialog) {
        ExportDialog(
            onDismiss = { showExportDialog = false },
            onExport = { format ->
                showExportDialog = false
                viewModel.exportToFormat(
                    android.content.ContextWrapper(navController.context),
                    "Class Schedule", 
                    format
                )
            }
        )
    }

    // Export success dialog
    if (uiState.exportSuccess) {
        AlertDialog(
            onDismissRequest = { viewModel.clearExportStatus() },
            title = { Text("تم التصدير بنجاح") },
            text = { Text("تم حفظ الملف بنجاح في مجلد التطبيق") },
            confirmButton = {
                Button(onClick = { viewModel.clearExportStatus() }) {
                    Text("موافق")
                }
            }
        )
    }

    // Export error dialog
    uiState.exportError?.let { error ->
        AlertDialog(
            onDismissRequest = { viewModel.clearExportStatus() },
            title = { Text("خطأ في التصدير") },
            text = { Text(error) },
            confirmButton = {
                Button(onClick = { viewModel.clearExportStatus() }) {
                    Text("موافق")
                }
            }
        )
    }
}

// Rest of the file remains the same...

=== file: app/src/main/java/com/smartschedule/presentation/viewmodel/ViewTimetableViewModel.kt ===
// UPDATED VERSION WITH MULTIPLE EXPORT FORMATS
package com.smartschedule.presentation.viewmodel

import android.content.Context
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.smartschedule.data.database.entities.LessonEntity
import com.smartschedule.domain.repository.TimetableRepository
import com.smartschedule.domain.usecase.ExportFormat
import com.smartschedule.domain.usecase.ExportTimetableUseCase
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch
import javax.inject.Inject

data class ViewTimetableUiState(
    val lessons: List<LessonEntity> = emptyList(),
    val isLoading: Boolean = true,
    val error: String? = null,
    val exportInProgress: Boolean = false,
    val exportSuccess: Boolean = false,
    val exportError: String? = null
)

@HiltViewModel
class ViewTimetableViewModel @Inject constructor(
    private val repository: TimetableRepository,
    private val exportUseCase: ExportTimetableUseCase
) : ViewModel() {
    private val _uiState = MutableStateFlow(ViewTimetableUiState())
    val uiState = _uiState.asStateFlow()

    init {
        loadLessons()
    }

    private fun loadLessons() {
        viewModelScope.launch {
            repository.getAllLessons()
                .catch { error ->
                    _uiState.update { it.copy(error = error.message, isLoading = false) }
                }
                .collect { lessons ->
                    _uiState.update { it.copy(lessons = lessons, isLoading = false) }
                }
        }
    }

    fun exportToFormat(context: Context, className: String, format: ExportFormat) = viewModelScope.launch {
        _uiState.update { it.copy(exportInProgress = true, exportError = null) }
        try {
            val currentTimetable = repository.getCurrentTimetable()
            if (currentTimetable != null) {
                val file = exportUseCase.exportTimetable(context, currentTimetable, className, format)
                if (file != null) {
                    _uiState.update { 
                        it.copy(
                            exportInProgress = false,
                            exportSuccess = true
                        ) 
                    }
                } else {
                    _uiState.update { 
                        it.copy(
                            exportInProgress = false,
                            exportError = "فشل في إنشاء الملف"
                        ) 
                    }
                }
            } else {
                _uiState.update { 
                    it.copy(
                        exportInProgress = false,
                        exportError = "لا يوجد جدول متاح للتصدير"
                    ) 
                }
            }
        } catch (e: Exception) {
            _uiState.update { 
                it.copy(
                    exportInProgress = false,
                    exportError = "فشل التصدير: ${e.message}"
                ) 
            }
        }
    }

    fun clearExportStatus() {
        _uiState.update { 
            it.copy(
                exportSuccess = false,
                exportError = null
            ) 
        }
    }

    fun clearError() {
        _uiState.update { it.copy(error = null) }
    }
}

=== file: app/src/main/java/com/smartschedule/presentation/navigation/AppNavigation.kt ===
// UPDATED VERSION WITH NEW SCREENS
package com.smartschedule.presentation.navigation

import androidx.compose.runtime.Composable
import androidx.navigation.compose.NavHost
import androidx.navigation.compose.composable
import androidx.navigation.compose.rememberNavController
import com.smartschedule.presentation.ui.screens.*

@Composable
fun AppNavigation() {
    val navController = rememberNavController()
    
    NavHost(
        navController = navController,
        startDestination = "main"
    ) {
        composable("main") { 
            MainScreen(navController = navController) 
        }
        composable("generate") { 
            GenerateTimetableScreen(navController = navController) 
        }
        composable("view_timetable") { 
            ViewTimetableScreen(navController = navController) 
        }
        composable("manage_subjects") { 
            ManageSubjectsScreen(navController = navController) 
        }
        composable("manage_teachers") { 
            ManageTeachersScreen(navController = navController) 
        }
        composable("manage_classes") { 
            ManageClassesScreen(navController = navController) 
        }
        composable("fitness_weights") { 
            FitnessWeightsScreen(navController = navController) 
        }
    }
}

=== file: app/src/main/java/com/smartschedule/presentation/ui/screens/MainScreen.kt ===
// UPDATED VERSION WITH FITNESS WEIGHTS NAVIGATION
// Add this to the action cards grid:
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun MainScreen(
    navController: NavController,
    viewModel: MainViewModel = hiltViewModel()
) {
    // ... existing code ...

    LazyVerticalGrid(
        columns = GridCells.Fixed(2),
        verticalArrangement = Arrangement.spacedBy(12.dp),
        horizontalArrangement = Arrangement.spacedBy(12.dp),
        modifier = Modifier.weight(1f)
    ) {
        // ... existing action cards ...
        
        item {
            ActionCard(
                title = "إعدادات الجدولة",
                subtitle = "ضبط أوزان المعايير",
                icon = Icons.Default.Tune,
                onClick = { navController.navigate("fitness_weights") }
            )
        }
        
        // ... rest of existing cards ...
    }
    
    // ... rest of existing code ...
}
```

=== file: app/src/main/java/com/smartschedule/presentation/ui/screens/FitnessWeightsScreen.kt ===
package com.smartschedule.presentation.ui.screens

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material.icons.filled.Save
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.navigation.NavController
import com.smartschedule.presentation.viewmodel.FitnessWeightsViewModel

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun FitnessWeightsScreen(
    navController: NavController,
    viewModel: FitnessWeightsViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsState()

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("إعدادات أوزان الجدولة") },
                navigationIcon = {
                    IconButton(onClick = { navController.navigateUp() }) {
                        Icon(Icons.Default.ArrowBack, contentDescription = "رجوع")
                    }
                },
                actions = {
                    IconButton(
                        onClick = { viewModel.saveWeights() },
                        enabled = uiState.isValid
                    ) {
                        Icon(Icons.Default.Save, contentDescription = "حفظ")
                    }
                }
            )
        }
    ) { paddingValues ->
        LazyColumn(
            modifier = Modifier
                .padding(paddingValues)
                .fillMaxSize()
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            item {
                Text(
                    text = "ضبط أوزان معايير الجدولة",
                    style = MaterialTheme.typography.headlineSmall,
                    fontWeight = FontWeight.Bold
                )
                Text(
                    text = "مجموع الأوزان يجب أن يكون قريباً من 1.0 للحصول على أفضل النتائج",
                    style = MaterialTheme.typography.bodyMedium,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }

            item { 
                WeightSlider(
                    title = "صراعات المدرسين",
                    value = uiState.weights.teacherConflict,
                    onValueChange = { viewModel.updateTeacherConflict(it) }
                )
            }

            item { 
                WeightSlider(
                    title = "صراعات الفصول", 
                    value = uiState.weights.classConflict,
                    onValueChange = { viewModel.updateClassConflict(it) }
                )
            }

            item { 
                WeightSlider(
                    title = "صراعات القاعات",
                    value = uiState.weights.roomConflict,
                    onValueChange = { viewModel.updateRoomConflict(it) }
                )
            }

            item { 
                WeightSlider(
                    title = "عدم تطابق المدرس مع المادة",
                    value = uiState.weights.teacherSubjectMismatch,
                    onValueChange = { viewModel.updateTeacherSubjectMismatch(it) }
                )
            }

            item { 
                WeightSlider(
                    title = "تجاوز سعة القاعة",
                    value = uiState.weights.roomCapacityViolation,
                    onValueChange = { viewModel.updateRoomCapacityViolation(it) }
                )
            }

            item { 
                WeightSlider(
                    title = "توزيع الحصص على الأيام",
                    value = uiState.weights.distributionPenalty,
                    onValueChange = { viewModel.updateDistributionPenalty(it) }
                )
            }

            item { 
                WeightSlider(
                    title = "الفجوات بين الحصص",
                    value = uiState.weights.gapPenalty,
                    onValueChange = { viewModel.updateGapPenalty(it) }
                )
            }

            item { 
                WeightSlider(
                    title = "عبء العمل على المدرسين", 
                    value = uiState.weights.teacherLoadPenalty,
                    onValueChange = { viewModel.updateTeacherLoadPenalty(it) }
                )
            }

            item { 
                WeightSlider(
                    title = "استخدام القاعات",
                    value = uiState.weights.roomUtilizationPenalty,
                    onValueChange = { viewModel.updateRoomUtilizationPenalty(it) }
                )
            }

            item {
                TotalWeightCard(
                    total = uiState.totalWeight,
                    isValid = uiState.isValid
                )
            }

            item {
                PresetWeightsSection(
                    onSelectPreset = { preset -> viewModel.applyPreset(preset) }
                )
            }
        }
    }

    if (uiState.showSaveSuccess) {
        AlertDialog(
            onDismissRequest = { viewModel.dismissSaveSuccess() },
            title = { Text("تم الحفظ") },
            text = { Text("تم حفظ إعدادات الأوزان بنجاح وسيتم تطبيقها في الجدولة القادمة") },
            confirmButton = {
                Button(onClick = { 
                    viewModel.dismissSaveSuccess()
                    navController.navigateUp()
                }) {
                    Text("موافق")
                }
            }
        )
    }
}

@Composable
fun WeightSlider(
    title: String,
    value: Double,
    onValueChange: (Double) -> Unit
) {
    Card(
        colors = CardDefaults.cardColors(
            containerColor = MaterialTheme.colorScheme.surfaceVariant
        )
    ) {
        Column(modifier = Modifier.padding(16.dp)) {
            Text(
                text = title,
                style = MaterialTheme.typography.titleMedium,
                fontWeight = FontWeight.Medium
            )
            
            Spacer(modifier = Modifier.height(12.dp))
            
            Row(
                verticalAlignment = Alignment.CenterVertically,
                modifier = Modifier.fillMaxWidth()
            ) {
                Text(
                    text = String.format("%.2f", value),
                    style = MaterialTheme.typography.bodyMedium,
                    modifier = Modifier.width(50.dp)
                )
                
                Spacer(modifier = Modifier.width(16.dp))
                
                Slider(
                    value = value.toFloat(),
                    onValueChange = { onValueChange(it.toDouble()) },
                    valueRange = 0f..0.3f,
                    steps = 29,
                    modifier = Modifier.weight(1f)
                )
            }
        }
    }
}

@Composable
fun TotalWeightCard(total: Double, isValid: Boolean) {
    Card(
        colors = CardDefaults.cardColors(
            containerColor = if (isValid) 
                MaterialTheme.colorScheme.primaryContainer 
            else 
                MaterialTheme.colorScheme.errorContainer
        )
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(20.dp),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            Text(
                text = "المجموع الكلي",
                style = MaterialTheme.typography.titleMedium,
                fontWeight = FontWeight.Bold
            )
            
            Spacer(modifier = Modifier.height(8.dp))
            
            Text(
                text = String.format("%.3f", total),
                style = MaterialTheme.typography.headlineMedium,
                fontWeight = FontWeight.Bold,
                color = if (isValid) 
                    MaterialTheme.colorScheme.onPrimaryContainer 
                else 
                    MaterialTheme.colorScheme.onErrorContainer
            )
            
            Spacer(modifier = Modifier.height(8.dp))
            
            Text(
                text = if (isValid) {
                    "✓ الأوزان متوازنة بشكل جيد"
                } else {
                    "⚠️ يجب تعديل الأوزان لتكون قريبة من 1.0"
                },
                style = MaterialTheme.typography.bodyMedium,
                color = if (isValid) 
                    MaterialTheme.colorScheme.onPrimaryContainer 
                else 
                    MaterialTheme.colorScheme.onErrorContainer
            )
        }
    }
}

@Composable
fun PresetWeightsSection(onSelectPreset: (FitnessWeightsPreset) -> Unit) {
    var expanded by remember { mutableStateOf(false) }
    
    Card {
        Column(modifier = Modifier.padding(16.dp)) {
            Text(
                text = "الإعدادات المسبقة",
                style = MaterialTheme.typography.titleMedium,
                fontWeight = FontWeight.Medium
            )
            
            Spacer(modifier = Modifier.height(12.dp))
            
            ExposedDropdownMenuBox(
                expanded = expanded,
                onExpandedChange = { expanded = !expanded }
            ) {
                TextField(
                    value = "اختر إعداداً مسبقاً",
                    onValueChange = {},
                    readOnly = true,
                    trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(expanded = expanded) },
                    modifier = Modifier
                        .fillMaxWidth()
                        .menuAnchor()
                )
                
                ExposedDropdownMenu(
                    expanded = expanded,
                    onDismissRequest = { expanded = false }
                ) {
                    FitnessWeightsPreset.entries.forEach { preset ->
                        DropdownMenuItem(
                            text = { Text(preset.displayName) },
                            onClick = {
                                onSelectPreset(preset)
                                expanded = false
                            }
                        )
                    }
                }
            }
            
            Spacer(modifier = Modifier.height(8.dp))
            
            Text(
                text = "الإعدادات المسبقة تساعد في تحقيق أهداف محددة للجدولة",
                style = MaterialTheme.typography.bodySmall,
                color = MaterialTheme.colorScheme.onSurfaceVariant
            )
        }
    }
}

=== file: app/src/main/java/com/smartschedule/domain/models/FitnessWeightsPreset.kt ===
package com.smartschedule.domain.models

enum class FitnessWeightsPreset(val displayName: String, val weights: FitnessWeights) {
    BALANCED("متوازن", FitnessWeights(
        teacherConflict = 0.15,
        classConflict = 0.15,
        roomConflict = 0.15,
        teacherSubjectMismatch = 0.12,
        roomCapacityViolation = 0.12,
        distributionPenalty = 0.08,
        gapPenalty = 0.06,
        teacherLoadPenalty = 0.05,
        roomUtilizationPenalty = 0.04
    )),
    
    TEACHER_FOCUS("مركز على المدرسين", FitnessWeights(
        teacherConflict = 0.20,
        classConflict = 0.12,
        roomConflict = 0.12,
        teacherSubjectMismatch = 0.15,
        roomCapacityViolation = 0.10,
        distributionPenalty = 0.08,
        gapPenalty = 0.05,
        teacherLoadPenalty = 0.10,
        roomUtilizationPenalty = 0.03
    )),
    
    ROOM_FOCUS("مركز على القاعات", FitnessWeights(
        teacherConflict = 0.12,
        classConflict = 0.12,
        roomConflict = 0.20,
        teacherSubjectMismatch = 0.10,
        roomCapacityViolation = 0.15,
        distributionPenalty = 0.07,
        gapPenalty = 0.05,
        teacherLoadPenalty = 0.04,
        roomUtilizationPenalty = 0.10
    )),
    
    STUDENT_FOCUS("مركز على الطلاب", FitnessWeights(
        teacherConflict = 0.12,
        classConflict = 0.18,
        roomConflict = 0.12,
        teacherSubjectMismatch = 0.10,
        roomCapacityViolation = 0.15,
        distributionPenalty = 0.10,
        gapPenalty = 0.08,
        teacherLoadPenalty = 0.05,
        roomUtilizationPenalty = 0.05
    ))
}

=== file: app/src/main/java/com/smartschedule/presentation/viewmodel/FitnessWeightsViewModel.kt ===
package com.smartschedule.presentation.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.smartschedule.domain.models.FitnessWeights
import com.smartschedule.domain.models.FitnessWeightsPreset
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import javax.inject.Inject

data class FitnessWeightsUiState(
    val weights: FitnessWeights = FitnessWeights(),
    val showSaveSuccess: Boolean = false,
    val error: String? = null
) {
    val totalWeight: Double get() = 
        weights.teacherConflict + weights.classConflict + weights.roomConflict +
        weights.teacherSubjectMismatch + weights.roomCapacityViolation +
        weights.distributionPenalty + weights.gapPenalty +
        weights.teacherLoadPenalty + weights.roomUtilizationPenalty
    
    val isValid: Boolean get() = totalWeight in 0.9..1.1
}

@HiltViewModel
class FitnessWeightsViewModel @Inject constructor() : ViewModel() {
    private val _uiState = MutableStateFlow(FitnessWeightsUiState())
    val uiState: StateFlow<FitnessWeightsUiState> = _uiState.asStateFlow()

    fun updateTeacherConflict(value: Double) {
        updateWeights { it.copy(teacherConflict = value) }
    }

    fun updateClassConflict(value: Double) {
        updateWeights { it.copy(classConflict = value) }
    }

    fun updateRoomConflict(value: Double) {
        updateWeights { it.copy(roomConflict = value) }
    }

    fun updateTeacherSubjectMismatch(value: Double) {
        updateWeights { it.copy(teacherSubjectMismatch = value) }
    }

    fun updateRoomCapacityViolation(value: Double) {
        updateWeights { it.copy(roomCapacityViolation = value) }
    }

    fun updateDistributionPenalty(value: Double) {
        updateWeights { it.copy(distributionPenalty = value) }
    }

    fun updateGapPenalty(value: Double) {
        updateWeights { it.copy(gapPenalty = value) }
    }

    fun updateTeacherLoadPenalty(value: Double) {
        updateWeights { it.copy(teacherLoadPenalty = value) }
    }

    fun updateRoomUtilizationPenalty(value: Double) {
        updateWeights { it.copy(roomUtilizationPenalty = value) }
    }

    private fun updateWeights(update: (FitnessWeights) -> FitnessWeights) {
        _uiState.value = _uiState.value.copy(
            weights = update(_uiState.value.weights)
        )
    }

    fun applyPreset(preset: FitnessWeightsPreset) {
        _uiState.value = _uiState.value.copy(
            weights = preset.weights
        )
    }

    fun saveWeights() {
        viewModelScope.launch {
            // TODO: Save to DataStore or SharedPreferences
            // For now, we'll just show success message
            _uiState.value = _uiState.value.copy(showSaveSuccess = true)
        }
    }

    fun dismissSaveSuccess() {
        _uiState.value = _uiState.value.copy(showSaveSuccess = false)
    }
}

=== file: app/src/main/java/com/smartschedule/data/local/PreferencesManager.kt ===
package com.smartschedule.data.local

import android.content.Context
import androidx.datastore.core.DataStore
import androidx.datastore.preferences.core.Preferences
import androidx.datastore.preferences.core.edit
import androidx.datastore.preferences.core.floatPreferencesKey
import androidx.datastore.preferences.preferencesDataStore
import com.smartschedule.domain.models.FitnessWeights
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import javax.inject.Inject

val Context.dataStore: DataStore<Preferences> by preferencesDataStore(name = "smartschedule_preferences")

class PreferencesManager @Inject constructor(
    private val context: Context
) {
    private object PreferencesKeys {
        val TEACHER_CONFLICT = floatPreferencesKey("teacher_conflict")
        val CLASS_CONFLICT = floatPreferencesKey("class_conflict")
        val ROOM_CONFLICT = floatPreferencesKey("room_conflict")
        val TEACHER_SUBJECT_MISMATCH = floatPreferencesKey("teacher_subject_mismatch")
        val ROOM_CAPACITY_VIOLATION = floatPreferencesKey("room_capacity_violation")
        val DISTRIBUTION_PENALTY = floatPreferencesKey("distribution_penalty")
        val GAP_PENALTY = floatPreferencesKey("gap_penalty")
        val TEACHER_LOAD_PENALTY = floatPreferencesKey("teacher_load_penalty")
        val ROOM_UTILIZATION_PENALTY = floatPreferencesKey("room_utilization_penalty")
    }

    val fitnessWeights: Flow<FitnessWeights> = context.dataStore.data.map { preferences ->
        FitnessWeights(
            teacherConflict = preferences[PreferencesKeys.TEACHER_CONFLICT]?.toDouble() ?: 0.15,
            classConflict = preferences[PreferencesKeys.CLASS_CONFLICT]?.toDouble() ?: 0.15,
            roomConflict = preferences[PreferencesKeys.ROOM_CONFLICT]?.toDouble() ?: 0.15,
            teacherSubjectMismatch = preferences[PreferencesKeys.TEACHER_SUBJECT_MISMATCH]?.toDouble() ?: 0.12,
            roomCapacityViolation = preferences[PreferencesKeys.ROOM_CAPACITY_VIOLATION]?.toDouble() ?: 0.12,
            distributionPenalty = preferences[PreferencesKeys.DISTRIBUTION_PENALTY]?.toDouble() ?: 0.08,
            gapPenalty = preferences[PreferencesKeys.GAP_PENALTY]?.toDouble() ?: 0.06,
            teacherLoadPenalty = preferences[PreferencesKeys.TEACHER_LOAD_PENALTY]?.toDouble() ?: 0.05,
            roomUtilizationPenalty = preferences[PreferencesKeys.ROOM_UTILIZATION_PENALTY]?.toDouble() ?: 0.04
        )
    }

    suspend fun saveFitnessWeights(weights: FitnessWeights) {
        context.dataStore.edit { preferences ->
            preferences[PreferencesKeys.TEACHER_CONFLICT] = weights.teacherConflict.toFloat()
            preferences[PreferencesKeys.CLASS_CONFLICT] = weights.classConflict.toFloat()
            preferences[PreferencesKeys.ROOM_CONFLICT] = weights.roomConflict.toFloat()
            preferences[PreferencesKeys.TEACHER_SUBJECT_MISMATCH] = weights.teacherSubjectMismatch.toFloat()
            preferences[PreferencesKeys.ROOM_CAPACITY_VIOLATION] = weights.roomCapacityViolation.toFloat()
            preferences[PreferencesKeys.DISTRIBUTION_PENALTY] = weights.distributionPenalty.toFloat()
            preferences[PreferencesKeys.GAP_PENALTY] = weights.gapPenalty.toFloat()
            preferences[PreferencesKeys.TEACHER_LOAD_PENALTY] = weights.teacherLoadPenalty.toFloat()
            preferences[PreferencesKeys.ROOM_UTILIZATION_PENALTY] = weights.roomUtilizationPenalty.toFloat()
        }
    }
}

=== file: app/src/main/java/com/smartschedule/di/PreferencesModule.kt ===
package com.smartschedule.di

import android.content.Context
import com.smartschedule.data.local.PreferencesManager
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.android.qualifiers.ApplicationContext
import dagger.hilt.components.SingletonComponent
import javax.inject.Singleton

@Module
@InstallIn(SingletonComponent::class)
object PreferencesModule {

    @Provides
    @Singleton
    fun providePreferencesManager(@ApplicationContext context: Context): PreferencesManager {
        return PreferencesManager(context)
    }
}

=== file: app/src/main/java/com/smartschedule/presentation/viewmodel/FitnessWeightsViewModel.kt ===
// UPDATED VERSION WITH PREFERENCES
package com.smartschedule.presentation.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.smartschedule.data.local.PreferencesManager
import com.smartschedule.domain.models.FitnessWeights
import com.smartschedule.domain.models.FitnessWeightsPreset
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.collect
import kotlinx.coroutines.launch
import javax.inject.Inject

@HiltViewModel
class FitnessWeightsViewModel @Inject constructor(
    private val preferencesManager: PreferencesManager
) : ViewModel() {
    private val _uiState = MutableStateFlow(FitnessWeightsUiState())
    val uiState: StateFlow<FitnessWeightsUiState> = _uiState.asStateFlow()

    init {
        loadSavedWeights()
    }

    private fun loadSavedWeights() {
        viewModelScope.launch {
            preferencesManager.fitnessWeights.collect { weights ->
                _uiState.value = FitnessWeightsUiState(weights = weights)
            }
        }
    }

    // ... existing update methods ...

    fun saveWeights() {
        viewModelScope.launch {
            try {
                preferencesManager.saveFitnessWeights(_uiState.value.weights)
                _uiState.value = _uiState.value.copy(showSaveSuccess = true)
            } catch (e: Exception) {
                _uiState.value = _uiState.value.copy(error = "فشل في حفظ الإعدادات: ${e.message}")
            }
        }
    }

    // ... rest of existing methods ...
}

=== file: app/src/main/java/com/smartschedule/utils/algorithms/GeneticAlgorithmEngine.kt ===
// UPDATED VERSION WITH CUSTOM WEIGHTS
package com.smartschedule.utils.algorithms

import com.smartschedule.data.local.PreferencesManager
import com.smartschedule.domain.models.FitnessWeights
import kotlinx.coroutines.flow.first
import javax.inject.Inject

class GeneticAlgorithmEngine @Inject constructor(
    private val preferencesManager: PreferencesManager
) {
    private var customWeights: FitnessWeights? = null

    suspend fun getCurrentWeights(): FitnessWeights {
        return customWeights ?: preferencesManager.fitnessWeights.first()
    }

    fun setCustomWeights(weights: FitnessWeights) {
        customWeights = weights
    }

    // Update calculateFitness function to use custom weights
    private suspend fun calculateFitness(
        timetable: DomainTimetable,
        subjects: List<Subject>,
        teachers: List<Teacher>,
        classes: List<SchoolClass>,
        rooms: List<Room>
    ): Double {
        val weights = getCurrentWeights()
        // Use weights in fitness calculation...
        val teacherConflicts = calculateTeacherConflicts(lessons)
        val classConflicts = calculateClassConflicts(lessons)
        // ... etc

        val hardPenalty = (teacherConflicts * weights.teacherConflict) + 
                         (classConflicts * weights.classConflict) + 
                         (roomConflicts * weights.roomConflict) + 
                         (teacherSubjectMismatch * weights.teacherSubjectMismatch) + 
                         (roomCapacityViolations * weights.roomCapacityViolation)

        val softPenalty = (distributionPenalty * weights.distributionPenalty) + 
                         (gapPenalty * weights.gapPenalty) + 
                         (teacherLoadPenalty * weights.teacherLoadPenalty) + 
                         (roomUtilizationPenalty * weights.roomUtilizationPenalty)

        // ... rest of calculation
    }
}